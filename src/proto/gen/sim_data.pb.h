// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: sim_data.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_sim_5fdata_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_sim_5fdata_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3013000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3013000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_sim_5fdata_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_sim_5fdata_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[12]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_sim_5fdata_2eproto;
namespace flight_panel {
class AircraftControls;
class AircraftControlsDefaultTypeInternal;
extern AircraftControlsDefaultTypeInternal _AircraftControls_default_instance_;
class AircraftInfo;
class AircraftInfoDefaultTypeInternal;
extern AircraftInfoDefaultTypeInternal _AircraftInfo_default_instance_;
class AircraftMiscSystem;
class AircraftMiscSystemDefaultTypeInternal;
extern AircraftMiscSystemDefaultTypeInternal _AircraftMiscSystem_default_instance_;
class Avionics;
class AvionicsDefaultTypeInternal;
extern AvionicsDefaultTypeInternal _Avionics_default_instance_;
class CourseDeviationIndicator;
class CourseDeviationIndicatorDefaultTypeInternal;
extern CourseDeviationIndicatorDefaultTypeInternal _CourseDeviationIndicator_default_instance_;
class EngineData;
class EngineDataDefaultTypeInternal;
extern EngineDataDefaultTypeInternal _EngineData_default_instance_;
class GameData;
class GameDataDefaultTypeInternal;
extern GameDataDefaultTypeInternal _GameData_default_instance_;
class HorizontalSituationIndicator;
class HorizontalSituationIndicatorDefaultTypeInternal;
extern HorizontalSituationIndicatorDefaultTypeInternal _HorizontalSituationIndicator_default_instance_;
class Instrument;
class InstrumentDefaultTypeInternal;
extern InstrumentDefaultTypeInternal _Instrument_default_instance_;
class NavigationSystem;
class NavigationSystemDefaultTypeInternal;
extern NavigationSystemDefaultTypeInternal _NavigationSystem_default_instance_;
class RadioChannel;
class RadioChannelDefaultTypeInternal;
extern RadioChannelDefaultTypeInternal _RadioChannel_default_instance_;
class SimData;
class SimDataDefaultTypeInternal;
extern SimDataDefaultTypeInternal _SimData_default_instance_;
}  // namespace flight_panel
PROTOBUF_NAMESPACE_OPEN
template<> ::flight_panel::AircraftControls* Arena::CreateMaybeMessage<::flight_panel::AircraftControls>(Arena*);
template<> ::flight_panel::AircraftInfo* Arena::CreateMaybeMessage<::flight_panel::AircraftInfo>(Arena*);
template<> ::flight_panel::AircraftMiscSystem* Arena::CreateMaybeMessage<::flight_panel::AircraftMiscSystem>(Arena*);
template<> ::flight_panel::Avionics* Arena::CreateMaybeMessage<::flight_panel::Avionics>(Arena*);
template<> ::flight_panel::CourseDeviationIndicator* Arena::CreateMaybeMessage<::flight_panel::CourseDeviationIndicator>(Arena*);
template<> ::flight_panel::EngineData* Arena::CreateMaybeMessage<::flight_panel::EngineData>(Arena*);
template<> ::flight_panel::GameData* Arena::CreateMaybeMessage<::flight_panel::GameData>(Arena*);
template<> ::flight_panel::HorizontalSituationIndicator* Arena::CreateMaybeMessage<::flight_panel::HorizontalSituationIndicator>(Arena*);
template<> ::flight_panel::Instrument* Arena::CreateMaybeMessage<::flight_panel::Instrument>(Arena*);
template<> ::flight_panel::NavigationSystem* Arena::CreateMaybeMessage<::flight_panel::NavigationSystem>(Arena*);
template<> ::flight_panel::RadioChannel* Arena::CreateMaybeMessage<::flight_panel::RadioChannel>(Arena*);
template<> ::flight_panel::SimData* Arena::CreateMaybeMessage<::flight_panel::SimData>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace flight_panel {

enum CourseDeviationIndicator_Direction : int {
  CourseDeviationIndicator_Direction_DIR_UNKNOWN = 0,
  CourseDeviationIndicator_Direction_DIR_TO = 1,
  CourseDeviationIndicator_Direction_DIR_FROM = 2,
  CourseDeviationIndicator_Direction_CourseDeviationIndicator_Direction_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  CourseDeviationIndicator_Direction_CourseDeviationIndicator_Direction_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool CourseDeviationIndicator_Direction_IsValid(int value);
constexpr CourseDeviationIndicator_Direction CourseDeviationIndicator_Direction_Direction_MIN = CourseDeviationIndicator_Direction_DIR_UNKNOWN;
constexpr CourseDeviationIndicator_Direction CourseDeviationIndicator_Direction_Direction_MAX = CourseDeviationIndicator_Direction_DIR_FROM;
constexpr int CourseDeviationIndicator_Direction_Direction_ARRAYSIZE = CourseDeviationIndicator_Direction_Direction_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CourseDeviationIndicator_Direction_descriptor();
template<typename T>
inline const std::string& CourseDeviationIndicator_Direction_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CourseDeviationIndicator_Direction>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CourseDeviationIndicator_Direction_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CourseDeviationIndicator_Direction_descriptor(), enum_t_value);
}
inline bool CourseDeviationIndicator_Direction_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CourseDeviationIndicator_Direction* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CourseDeviationIndicator_Direction>(
    CourseDeviationIndicator_Direction_descriptor(), name, value);
}
enum NavigationSystem_NavSource : int {
  NavigationSystem_NavSource_NAV_UNKNOWN = 0,
  NavigationSystem_NavSource_NAV_SOURCE_1 = 1,
  NavigationSystem_NavSource_NAV_SOURCE_2 = 2,
  NavigationSystem_NavSource_NAV_FMS = 3,
  NavigationSystem_NavSource_NavigationSystem_NavSource_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  NavigationSystem_NavSource_NavigationSystem_NavSource_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool NavigationSystem_NavSource_IsValid(int value);
constexpr NavigationSystem_NavSource NavigationSystem_NavSource_NavSource_MIN = NavigationSystem_NavSource_NAV_UNKNOWN;
constexpr NavigationSystem_NavSource NavigationSystem_NavSource_NavSource_MAX = NavigationSystem_NavSource_NAV_FMS;
constexpr int NavigationSystem_NavSource_NavSource_ARRAYSIZE = NavigationSystem_NavSource_NavSource_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* NavigationSystem_NavSource_descriptor();
template<typename T>
inline const std::string& NavigationSystem_NavSource_Name(T enum_t_value) {
  static_assert(::std::is_same<T, NavigationSystem_NavSource>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function NavigationSystem_NavSource_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    NavigationSystem_NavSource_descriptor(), enum_t_value);
}
inline bool NavigationSystem_NavSource_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, NavigationSystem_NavSource* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<NavigationSystem_NavSource>(
    NavigationSystem_NavSource_descriptor(), name, value);
}
// ===================================================================

class SimData PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flight_panel.SimData) */ {
 public:
  inline SimData() : SimData(nullptr) {}
  virtual ~SimData();

  SimData(const SimData& from);
  SimData(SimData&& from) noexcept
    : SimData() {
    *this = ::std::move(from);
  }

  inline SimData& operator=(const SimData& from) {
    CopyFrom(from);
    return *this;
  }
  inline SimData& operator=(SimData&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SimData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SimData* internal_default_instance() {
    return reinterpret_cast<const SimData*>(
               &_SimData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(SimData& a, SimData& b) {
    a.Swap(&b);
  }
  inline void Swap(SimData* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SimData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SimData* New() const final {
    return CreateMaybeMessage<SimData>(nullptr);
  }

  SimData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SimData>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SimData& from);
  void MergeFrom(const SimData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SimData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flight_panel.SimData";
  }
  protected:
  explicit SimData(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_sim_5fdata_2eproto);
    return ::descriptor_table_sim_5fdata_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAircraftInfoFieldNumber = 1,
    kAvionicsFieldNumber = 2,
    kAircraftMiscDataFieldNumber = 3,
    kEngineDataFieldNumber = 4,
    kInstrumentsFieldNumber = 5,
    kAircraftControlsFieldNumber = 6,
    kGameDataFieldNumber = 7,
  };
  // .flight_panel.AircraftInfo aircraft_info = 1;
  bool has_aircraft_info() const;
  private:
  bool _internal_has_aircraft_info() const;
  public:
  void clear_aircraft_info();
  const ::flight_panel::AircraftInfo& aircraft_info() const;
  ::flight_panel::AircraftInfo* release_aircraft_info();
  ::flight_panel::AircraftInfo* mutable_aircraft_info();
  void set_allocated_aircraft_info(::flight_panel::AircraftInfo* aircraft_info);
  private:
  const ::flight_panel::AircraftInfo& _internal_aircraft_info() const;
  ::flight_panel::AircraftInfo* _internal_mutable_aircraft_info();
  public:
  void unsafe_arena_set_allocated_aircraft_info(
      ::flight_panel::AircraftInfo* aircraft_info);
  ::flight_panel::AircraftInfo* unsafe_arena_release_aircraft_info();

  // .flight_panel.Avionics avionics = 2;
  bool has_avionics() const;
  private:
  bool _internal_has_avionics() const;
  public:
  void clear_avionics();
  const ::flight_panel::Avionics& avionics() const;
  ::flight_panel::Avionics* release_avionics();
  ::flight_panel::Avionics* mutable_avionics();
  void set_allocated_avionics(::flight_panel::Avionics* avionics);
  private:
  const ::flight_panel::Avionics& _internal_avionics() const;
  ::flight_panel::Avionics* _internal_mutable_avionics();
  public:
  void unsafe_arena_set_allocated_avionics(
      ::flight_panel::Avionics* avionics);
  ::flight_panel::Avionics* unsafe_arena_release_avionics();

  // .flight_panel.AircraftMiscSystem aircraft_misc_data = 3;
  bool has_aircraft_misc_data() const;
  private:
  bool _internal_has_aircraft_misc_data() const;
  public:
  void clear_aircraft_misc_data();
  const ::flight_panel::AircraftMiscSystem& aircraft_misc_data() const;
  ::flight_panel::AircraftMiscSystem* release_aircraft_misc_data();
  ::flight_panel::AircraftMiscSystem* mutable_aircraft_misc_data();
  void set_allocated_aircraft_misc_data(::flight_panel::AircraftMiscSystem* aircraft_misc_data);
  private:
  const ::flight_panel::AircraftMiscSystem& _internal_aircraft_misc_data() const;
  ::flight_panel::AircraftMiscSystem* _internal_mutable_aircraft_misc_data();
  public:
  void unsafe_arena_set_allocated_aircraft_misc_data(
      ::flight_panel::AircraftMiscSystem* aircraft_misc_data);
  ::flight_panel::AircraftMiscSystem* unsafe_arena_release_aircraft_misc_data();

  // .flight_panel.EngineData engine_data = 4;
  bool has_engine_data() const;
  private:
  bool _internal_has_engine_data() const;
  public:
  void clear_engine_data();
  const ::flight_panel::EngineData& engine_data() const;
  ::flight_panel::EngineData* release_engine_data();
  ::flight_panel::EngineData* mutable_engine_data();
  void set_allocated_engine_data(::flight_panel::EngineData* engine_data);
  private:
  const ::flight_panel::EngineData& _internal_engine_data() const;
  ::flight_panel::EngineData* _internal_mutable_engine_data();
  public:
  void unsafe_arena_set_allocated_engine_data(
      ::flight_panel::EngineData* engine_data);
  ::flight_panel::EngineData* unsafe_arena_release_engine_data();

  // .flight_panel.Instrument instruments = 5;
  bool has_instruments() const;
  private:
  bool _internal_has_instruments() const;
  public:
  void clear_instruments();
  const ::flight_panel::Instrument& instruments() const;
  ::flight_panel::Instrument* release_instruments();
  ::flight_panel::Instrument* mutable_instruments();
  void set_allocated_instruments(::flight_panel::Instrument* instruments);
  private:
  const ::flight_panel::Instrument& _internal_instruments() const;
  ::flight_panel::Instrument* _internal_mutable_instruments();
  public:
  void unsafe_arena_set_allocated_instruments(
      ::flight_panel::Instrument* instruments);
  ::flight_panel::Instrument* unsafe_arena_release_instruments();

  // .flight_panel.AircraftControls aircraft_controls = 6;
  bool has_aircraft_controls() const;
  private:
  bool _internal_has_aircraft_controls() const;
  public:
  void clear_aircraft_controls();
  const ::flight_panel::AircraftControls& aircraft_controls() const;
  ::flight_panel::AircraftControls* release_aircraft_controls();
  ::flight_panel::AircraftControls* mutable_aircraft_controls();
  void set_allocated_aircraft_controls(::flight_panel::AircraftControls* aircraft_controls);
  private:
  const ::flight_panel::AircraftControls& _internal_aircraft_controls() const;
  ::flight_panel::AircraftControls* _internal_mutable_aircraft_controls();
  public:
  void unsafe_arena_set_allocated_aircraft_controls(
      ::flight_panel::AircraftControls* aircraft_controls);
  ::flight_panel::AircraftControls* unsafe_arena_release_aircraft_controls();

  // .flight_panel.GameData game_data = 7;
  bool has_game_data() const;
  private:
  bool _internal_has_game_data() const;
  public:
  void clear_game_data();
  const ::flight_panel::GameData& game_data() const;
  ::flight_panel::GameData* release_game_data();
  ::flight_panel::GameData* mutable_game_data();
  void set_allocated_game_data(::flight_panel::GameData* game_data);
  private:
  const ::flight_panel::GameData& _internal_game_data() const;
  ::flight_panel::GameData* _internal_mutable_game_data();
  public:
  void unsafe_arena_set_allocated_game_data(
      ::flight_panel::GameData* game_data);
  ::flight_panel::GameData* unsafe_arena_release_game_data();

  // @@protoc_insertion_point(class_scope:flight_panel.SimData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::flight_panel::AircraftInfo* aircraft_info_;
  ::flight_panel::Avionics* avionics_;
  ::flight_panel::AircraftMiscSystem* aircraft_misc_data_;
  ::flight_panel::EngineData* engine_data_;
  ::flight_panel::Instrument* instruments_;
  ::flight_panel::AircraftControls* aircraft_controls_;
  ::flight_panel::GameData* game_data_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sim_5fdata_2eproto;
};
// -------------------------------------------------------------------

class AircraftInfo PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flight_panel.AircraftInfo) */ {
 public:
  inline AircraftInfo() : AircraftInfo(nullptr) {}
  virtual ~AircraftInfo();

  AircraftInfo(const AircraftInfo& from);
  AircraftInfo(AircraftInfo&& from) noexcept
    : AircraftInfo() {
    *this = ::std::move(from);
  }

  inline AircraftInfo& operator=(const AircraftInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline AircraftInfo& operator=(AircraftInfo&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AircraftInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AircraftInfo* internal_default_instance() {
    return reinterpret_cast<const AircraftInfo*>(
               &_AircraftInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(AircraftInfo& a, AircraftInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(AircraftInfo* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AircraftInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AircraftInfo* New() const final {
    return CreateMaybeMessage<AircraftInfo>(nullptr);
  }

  AircraftInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AircraftInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AircraftInfo& from);
  void MergeFrom(const AircraftInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AircraftInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flight_panel.AircraftInfo";
  }
  protected:
  explicit AircraftInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_sim_5fdata_2eproto);
    return ::descriptor_table_sim_5fdata_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kModelFieldNumber = 1,
    kCallSignFieldNumber = 2,
  };
  // string model = 1;
  void clear_model();
  const std::string& model() const;
  void set_model(const std::string& value);
  void set_model(std::string&& value);
  void set_model(const char* value);
  void set_model(const char* value, size_t size);
  std::string* mutable_model();
  std::string* release_model();
  void set_allocated_model(std::string* model);
  private:
  const std::string& _internal_model() const;
  void _internal_set_model(const std::string& value);
  std::string* _internal_mutable_model();
  public:

  // string call_sign = 2;
  void clear_call_sign();
  const std::string& call_sign() const;
  void set_call_sign(const std::string& value);
  void set_call_sign(std::string&& value);
  void set_call_sign(const char* value);
  void set_call_sign(const char* value, size_t size);
  std::string* mutable_call_sign();
  std::string* release_call_sign();
  void set_allocated_call_sign(std::string* call_sign);
  private:
  const std::string& _internal_call_sign() const;
  void _internal_set_call_sign(const std::string& value);
  std::string* _internal_mutable_call_sign();
  public:

  // @@protoc_insertion_point(class_scope:flight_panel.AircraftInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr call_sign_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sim_5fdata_2eproto;
};
// -------------------------------------------------------------------

class Avionics PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flight_panel.Avionics) */ {
 public:
  inline Avionics() : Avionics(nullptr) {}
  virtual ~Avionics();

  Avionics(const Avionics& from);
  Avionics(Avionics&& from) noexcept
    : Avionics() {
    *this = ::std::move(from);
  }

  inline Avionics& operator=(const Avionics& from) {
    CopyFrom(from);
    return *this;
  }
  inline Avionics& operator=(Avionics&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Avionics& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Avionics* internal_default_instance() {
    return reinterpret_cast<const Avionics*>(
               &_Avionics_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Avionics& a, Avionics& b) {
    a.Swap(&b);
  }
  inline void Swap(Avionics* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Avionics* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Avionics* New() const final {
    return CreateMaybeMessage<Avionics>(nullptr);
  }

  Avionics* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Avionics>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Avionics& from);
  void MergeFrom(const Avionics& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Avionics* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flight_panel.Avionics";
  }
  protected:
  explicit Avionics(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_sim_5fdata_2eproto);
    return ::descriptor_table_sim_5fdata_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTransponderCodeFieldNumber = 9,
    kCdi1FieldNumber = 1,
    kCdi2FieldNumber = 2,
    kNavRadio1FieldNumber = 4,
    kNavRadio2FieldNumber = 5,
    kComRadio1FieldNumber = 6,
    kComRadio2FieldNumber = 7,
    kAdfRadioFieldNumber = 8,
    kAdiRadialFieldNumber = 3,
  };
  // string transponder_code = 9;
  void clear_transponder_code();
  const std::string& transponder_code() const;
  void set_transponder_code(const std::string& value);
  void set_transponder_code(std::string&& value);
  void set_transponder_code(const char* value);
  void set_transponder_code(const char* value, size_t size);
  std::string* mutable_transponder_code();
  std::string* release_transponder_code();
  void set_allocated_transponder_code(std::string* transponder_code);
  private:
  const std::string& _internal_transponder_code() const;
  void _internal_set_transponder_code(const std::string& value);
  std::string* _internal_mutable_transponder_code();
  public:

  // .flight_panel.CourseDeviationIndicator cdi_1 = 1;
  bool has_cdi_1() const;
  private:
  bool _internal_has_cdi_1() const;
  public:
  void clear_cdi_1();
  const ::flight_panel::CourseDeviationIndicator& cdi_1() const;
  ::flight_panel::CourseDeviationIndicator* release_cdi_1();
  ::flight_panel::CourseDeviationIndicator* mutable_cdi_1();
  void set_allocated_cdi_1(::flight_panel::CourseDeviationIndicator* cdi_1);
  private:
  const ::flight_panel::CourseDeviationIndicator& _internal_cdi_1() const;
  ::flight_panel::CourseDeviationIndicator* _internal_mutable_cdi_1();
  public:
  void unsafe_arena_set_allocated_cdi_1(
      ::flight_panel::CourseDeviationIndicator* cdi_1);
  ::flight_panel::CourseDeviationIndicator* unsafe_arena_release_cdi_1();

  // .flight_panel.CourseDeviationIndicator cdi_2 = 2;
  bool has_cdi_2() const;
  private:
  bool _internal_has_cdi_2() const;
  public:
  void clear_cdi_2();
  const ::flight_panel::CourseDeviationIndicator& cdi_2() const;
  ::flight_panel::CourseDeviationIndicator* release_cdi_2();
  ::flight_panel::CourseDeviationIndicator* mutable_cdi_2();
  void set_allocated_cdi_2(::flight_panel::CourseDeviationIndicator* cdi_2);
  private:
  const ::flight_panel::CourseDeviationIndicator& _internal_cdi_2() const;
  ::flight_panel::CourseDeviationIndicator* _internal_mutable_cdi_2();
  public:
  void unsafe_arena_set_allocated_cdi_2(
      ::flight_panel::CourseDeviationIndicator* cdi_2);
  ::flight_panel::CourseDeviationIndicator* unsafe_arena_release_cdi_2();

  // .flight_panel.RadioChannel nav_radio_1 = 4;
  bool has_nav_radio_1() const;
  private:
  bool _internal_has_nav_radio_1() const;
  public:
  void clear_nav_radio_1();
  const ::flight_panel::RadioChannel& nav_radio_1() const;
  ::flight_panel::RadioChannel* release_nav_radio_1();
  ::flight_panel::RadioChannel* mutable_nav_radio_1();
  void set_allocated_nav_radio_1(::flight_panel::RadioChannel* nav_radio_1);
  private:
  const ::flight_panel::RadioChannel& _internal_nav_radio_1() const;
  ::flight_panel::RadioChannel* _internal_mutable_nav_radio_1();
  public:
  void unsafe_arena_set_allocated_nav_radio_1(
      ::flight_panel::RadioChannel* nav_radio_1);
  ::flight_panel::RadioChannel* unsafe_arena_release_nav_radio_1();

  // .flight_panel.RadioChannel nav_radio_2 = 5;
  bool has_nav_radio_2() const;
  private:
  bool _internal_has_nav_radio_2() const;
  public:
  void clear_nav_radio_2();
  const ::flight_panel::RadioChannel& nav_radio_2() const;
  ::flight_panel::RadioChannel* release_nav_radio_2();
  ::flight_panel::RadioChannel* mutable_nav_radio_2();
  void set_allocated_nav_radio_2(::flight_panel::RadioChannel* nav_radio_2);
  private:
  const ::flight_panel::RadioChannel& _internal_nav_radio_2() const;
  ::flight_panel::RadioChannel* _internal_mutable_nav_radio_2();
  public:
  void unsafe_arena_set_allocated_nav_radio_2(
      ::flight_panel::RadioChannel* nav_radio_2);
  ::flight_panel::RadioChannel* unsafe_arena_release_nav_radio_2();

  // .flight_panel.RadioChannel com_radio_1 = 6;
  bool has_com_radio_1() const;
  private:
  bool _internal_has_com_radio_1() const;
  public:
  void clear_com_radio_1();
  const ::flight_panel::RadioChannel& com_radio_1() const;
  ::flight_panel::RadioChannel* release_com_radio_1();
  ::flight_panel::RadioChannel* mutable_com_radio_1();
  void set_allocated_com_radio_1(::flight_panel::RadioChannel* com_radio_1);
  private:
  const ::flight_panel::RadioChannel& _internal_com_radio_1() const;
  ::flight_panel::RadioChannel* _internal_mutable_com_radio_1();
  public:
  void unsafe_arena_set_allocated_com_radio_1(
      ::flight_panel::RadioChannel* com_radio_1);
  ::flight_panel::RadioChannel* unsafe_arena_release_com_radio_1();

  // .flight_panel.RadioChannel com_radio_2 = 7;
  bool has_com_radio_2() const;
  private:
  bool _internal_has_com_radio_2() const;
  public:
  void clear_com_radio_2();
  const ::flight_panel::RadioChannel& com_radio_2() const;
  ::flight_panel::RadioChannel* release_com_radio_2();
  ::flight_panel::RadioChannel* mutable_com_radio_2();
  void set_allocated_com_radio_2(::flight_panel::RadioChannel* com_radio_2);
  private:
  const ::flight_panel::RadioChannel& _internal_com_radio_2() const;
  ::flight_panel::RadioChannel* _internal_mutable_com_radio_2();
  public:
  void unsafe_arena_set_allocated_com_radio_2(
      ::flight_panel::RadioChannel* com_radio_2);
  ::flight_panel::RadioChannel* unsafe_arena_release_com_radio_2();

  // .flight_panel.RadioChannel adf_radio = 8;
  bool has_adf_radio() const;
  private:
  bool _internal_has_adf_radio() const;
  public:
  void clear_adf_radio();
  const ::flight_panel::RadioChannel& adf_radio() const;
  ::flight_panel::RadioChannel* release_adf_radio();
  ::flight_panel::RadioChannel* mutable_adf_radio();
  void set_allocated_adf_radio(::flight_panel::RadioChannel* adf_radio);
  private:
  const ::flight_panel::RadioChannel& _internal_adf_radio() const;
  ::flight_panel::RadioChannel* _internal_mutable_adf_radio();
  public:
  void unsafe_arena_set_allocated_adf_radio(
      ::flight_panel::RadioChannel* adf_radio);
  ::flight_panel::RadioChannel* unsafe_arena_release_adf_radio();

  // double adi_radial = 3;
  void clear_adi_radial();
  double adi_radial() const;
  void set_adi_radial(double value);
  private:
  double _internal_adi_radial() const;
  void _internal_set_adi_radial(double value);
  public:

  // @@protoc_insertion_point(class_scope:flight_panel.Avionics)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr transponder_code_;
  ::flight_panel::CourseDeviationIndicator* cdi_1_;
  ::flight_panel::CourseDeviationIndicator* cdi_2_;
  ::flight_panel::RadioChannel* nav_radio_1_;
  ::flight_panel::RadioChannel* nav_radio_2_;
  ::flight_panel::RadioChannel* com_radio_1_;
  ::flight_panel::RadioChannel* com_radio_2_;
  ::flight_panel::RadioChannel* adf_radio_;
  double adi_radial_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sim_5fdata_2eproto;
};
// -------------------------------------------------------------------

class RadioChannel PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flight_panel.RadioChannel) */ {
 public:
  inline RadioChannel() : RadioChannel(nullptr) {}
  virtual ~RadioChannel();

  RadioChannel(const RadioChannel& from);
  RadioChannel(RadioChannel&& from) noexcept
    : RadioChannel() {
    *this = ::std::move(from);
  }

  inline RadioChannel& operator=(const RadioChannel& from) {
    CopyFrom(from);
    return *this;
  }
  inline RadioChannel& operator=(RadioChannel&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RadioChannel& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RadioChannel* internal_default_instance() {
    return reinterpret_cast<const RadioChannel*>(
               &_RadioChannel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(RadioChannel& a, RadioChannel& b) {
    a.Swap(&b);
  }
  inline void Swap(RadioChannel* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RadioChannel* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RadioChannel* New() const final {
    return CreateMaybeMessage<RadioChannel>(nullptr);
  }

  RadioChannel* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RadioChannel>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RadioChannel& from);
  void MergeFrom(const RadioChannel& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RadioChannel* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flight_panel.RadioChannel";
  }
  protected:
  explicit RadioChannel(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_sim_5fdata_2eproto);
    return ::descriptor_table_sim_5fdata_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kActiveFreqFieldNumber = 1,
    kStandbyFreqFieldNumber = 2,
  };
  // double active_freq = 1;
  void clear_active_freq();
  double active_freq() const;
  void set_active_freq(double value);
  private:
  double _internal_active_freq() const;
  void _internal_set_active_freq(double value);
  public:

  // double standby_freq = 2;
  void clear_standby_freq();
  double standby_freq() const;
  void set_standby_freq(double value);
  private:
  double _internal_standby_freq() const;
  void _internal_set_standby_freq(double value);
  public:

  // @@protoc_insertion_point(class_scope:flight_panel.RadioChannel)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  double active_freq_;
  double standby_freq_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sim_5fdata_2eproto;
};
// -------------------------------------------------------------------

class CourseDeviationIndicator PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flight_panel.CourseDeviationIndicator) */ {
 public:
  inline CourseDeviationIndicator() : CourseDeviationIndicator(nullptr) {}
  virtual ~CourseDeviationIndicator();

  CourseDeviationIndicator(const CourseDeviationIndicator& from);
  CourseDeviationIndicator(CourseDeviationIndicator&& from) noexcept
    : CourseDeviationIndicator() {
    *this = ::std::move(from);
  }

  inline CourseDeviationIndicator& operator=(const CourseDeviationIndicator& from) {
    CopyFrom(from);
    return *this;
  }
  inline CourseDeviationIndicator& operator=(CourseDeviationIndicator&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CourseDeviationIndicator& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CourseDeviationIndicator* internal_default_instance() {
    return reinterpret_cast<const CourseDeviationIndicator*>(
               &_CourseDeviationIndicator_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(CourseDeviationIndicator& a, CourseDeviationIndicator& b) {
    a.Swap(&b);
  }
  inline void Swap(CourseDeviationIndicator* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CourseDeviationIndicator* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CourseDeviationIndicator* New() const final {
    return CreateMaybeMessage<CourseDeviationIndicator>(nullptr);
  }

  CourseDeviationIndicator* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CourseDeviationIndicator>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CourseDeviationIndicator& from);
  void MergeFrom(const CourseDeviationIndicator& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CourseDeviationIndicator* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flight_panel.CourseDeviationIndicator";
  }
  protected:
  explicit CourseDeviationIndicator(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_sim_5fdata_2eproto);
    return ::descriptor_table_sim_5fdata_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef CourseDeviationIndicator_Direction Direction;
  static constexpr Direction DIR_UNKNOWN =
    CourseDeviationIndicator_Direction_DIR_UNKNOWN;
  static constexpr Direction DIR_TO =
    CourseDeviationIndicator_Direction_DIR_TO;
  static constexpr Direction DIR_FROM =
    CourseDeviationIndicator_Direction_DIR_FROM;
  static inline bool Direction_IsValid(int value) {
    return CourseDeviationIndicator_Direction_IsValid(value);
  }
  static constexpr Direction Direction_MIN =
    CourseDeviationIndicator_Direction_Direction_MIN;
  static constexpr Direction Direction_MAX =
    CourseDeviationIndicator_Direction_Direction_MAX;
  static constexpr int Direction_ARRAYSIZE =
    CourseDeviationIndicator_Direction_Direction_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Direction_descriptor() {
    return CourseDeviationIndicator_Direction_descriptor();
  }
  template<typename T>
  static inline const std::string& Direction_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Direction>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Direction_Name.");
    return CourseDeviationIndicator_Direction_Name(enum_t_value);
  }
  static inline bool Direction_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Direction* value) {
    return CourseDeviationIndicator_Direction_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kObsDegFieldNumber = 1,
    kRadialErrorFieldNumber = 2,
    kGlideSlopeErrorFieldNumber = 3,
    kDirectionFieldNumber = 4,
    kGlisdeslopeFlagFieldNumber = 5,
  };
  // double obs_deg = 1;
  void clear_obs_deg();
  double obs_deg() const;
  void set_obs_deg(double value);
  private:
  double _internal_obs_deg() const;
  void _internal_set_obs_deg(double value);
  public:

  // double radial_error = 2;
  void clear_radial_error();
  double radial_error() const;
  void set_radial_error(double value);
  private:
  double _internal_radial_error() const;
  void _internal_set_radial_error(double value);
  public:

  // double glide_slope_error = 3;
  void clear_glide_slope_error();
  double glide_slope_error() const;
  void set_glide_slope_error(double value);
  private:
  double _internal_glide_slope_error() const;
  void _internal_set_glide_slope_error(double value);
  public:

  // .flight_panel.CourseDeviationIndicator.Direction direction = 4;
  void clear_direction();
  ::flight_panel::CourseDeviationIndicator_Direction direction() const;
  void set_direction(::flight_panel::CourseDeviationIndicator_Direction value);
  private:
  ::flight_panel::CourseDeviationIndicator_Direction _internal_direction() const;
  void _internal_set_direction(::flight_panel::CourseDeviationIndicator_Direction value);
  public:

  // bool glisdeslope_flag = 5;
  void clear_glisdeslope_flag();
  bool glisdeslope_flag() const;
  void set_glisdeslope_flag(bool value);
  private:
  bool _internal_glisdeslope_flag() const;
  void _internal_set_glisdeslope_flag(bool value);
  public:

  // @@protoc_insertion_point(class_scope:flight_panel.CourseDeviationIndicator)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  double obs_deg_;
  double radial_error_;
  double glide_slope_error_;
  int direction_;
  bool glisdeslope_flag_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sim_5fdata_2eproto;
};
// -------------------------------------------------------------------

class AircraftMiscSystem PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flight_panel.AircraftMiscSystem) */ {
 public:
  inline AircraftMiscSystem() : AircraftMiscSystem(nullptr) {}
  virtual ~AircraftMiscSystem();

  AircraftMiscSystem(const AircraftMiscSystem& from);
  AircraftMiscSystem(AircraftMiscSystem&& from) noexcept
    : AircraftMiscSystem() {
    *this = ::std::move(from);
  }

  inline AircraftMiscSystem& operator=(const AircraftMiscSystem& from) {
    CopyFrom(from);
    return *this;
  }
  inline AircraftMiscSystem& operator=(AircraftMiscSystem&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AircraftMiscSystem& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AircraftMiscSystem* internal_default_instance() {
    return reinterpret_cast<const AircraftMiscSystem*>(
               &_AircraftMiscSystem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(AircraftMiscSystem& a, AircraftMiscSystem& b) {
    a.Swap(&b);
  }
  inline void Swap(AircraftMiscSystem* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AircraftMiscSystem* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AircraftMiscSystem* New() const final {
    return CreateMaybeMessage<AircraftMiscSystem>(nullptr);
  }

  AircraftMiscSystem* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AircraftMiscSystem>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AircraftMiscSystem& from);
  void MergeFrom(const AircraftMiscSystem& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AircraftMiscSystem* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flight_panel.AircraftMiscSystem";
  }
  protected:
  explicit AircraftMiscSystem(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_sim_5fdata_2eproto);
    return ::descriptor_table_sim_5fdata_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBatteryBusVoltFieldNumber = 1,
    kAmbientTempFieldNumber = 2,
  };
  // double battery_bus_volt = 1;
  void clear_battery_bus_volt();
  double battery_bus_volt() const;
  void set_battery_bus_volt(double value);
  private:
  double _internal_battery_bus_volt() const;
  void _internal_set_battery_bus_volt(double value);
  public:

  // double ambient_temp = 2;
  void clear_ambient_temp();
  double ambient_temp() const;
  void set_ambient_temp(double value);
  private:
  double _internal_ambient_temp() const;
  void _internal_set_ambient_temp(double value);
  public:

  // @@protoc_insertion_point(class_scope:flight_panel.AircraftMiscSystem)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  double battery_bus_volt_;
  double ambient_temp_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sim_5fdata_2eproto;
};
// -------------------------------------------------------------------

class EngineData PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flight_panel.EngineData) */ {
 public:
  inline EngineData() : EngineData(nullptr) {}
  virtual ~EngineData();

  EngineData(const EngineData& from);
  EngineData(EngineData&& from) noexcept
    : EngineData() {
    *this = ::std::move(from);
  }

  inline EngineData& operator=(const EngineData& from) {
    CopyFrom(from);
    return *this;
  }
  inline EngineData& operator=(EngineData&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const EngineData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EngineData* internal_default_instance() {
    return reinterpret_cast<const EngineData*>(
               &_EngineData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(EngineData& a, EngineData& b) {
    a.Swap(&b);
  }
  inline void Swap(EngineData* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EngineData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline EngineData* New() const final {
    return CreateMaybeMessage<EngineData>(nullptr);
  }

  EngineData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<EngineData>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const EngineData& from);
  void MergeFrom(const EngineData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EngineData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flight_panel.EngineData";
  }
  protected:
  explicit EngineData(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_sim_5fdata_2eproto);
    return ::descriptor_table_sim_5fdata_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRpmFieldNumber = 1,
    kRpmAmbiemtPctFieldNumber = 2,
    kEngineElapsedTimeFieldNumber = 3,
    kFuelLeftLevelFieldNumber = 4,
    kFuelRightLevelFieldNumber = 5,
  };
  // double rpm = 1;
  void clear_rpm();
  double rpm() const;
  void set_rpm(double value);
  private:
  double _internal_rpm() const;
  void _internal_set_rpm(double value);
  public:

  // double rpm_ambiemt_pct = 2;
  void clear_rpm_ambiemt_pct();
  double rpm_ambiemt_pct() const;
  void set_rpm_ambiemt_pct(double value);
  private:
  double _internal_rpm_ambiemt_pct() const;
  void _internal_set_rpm_ambiemt_pct(double value);
  public:

  // double engine_elapsed_time = 3;
  void clear_engine_elapsed_time();
  double engine_elapsed_time() const;
  void set_engine_elapsed_time(double value);
  private:
  double _internal_engine_elapsed_time() const;
  void _internal_set_engine_elapsed_time(double value);
  public:

  // double fuel_left_level = 4;
  void clear_fuel_left_level();
  double fuel_left_level() const;
  void set_fuel_left_level(double value);
  private:
  double _internal_fuel_left_level() const;
  void _internal_set_fuel_left_level(double value);
  public:

  // double fuel_right_level = 5;
  void clear_fuel_right_level();
  double fuel_right_level() const;
  void set_fuel_right_level(double value);
  private:
  double _internal_fuel_right_level() const;
  void _internal_set_fuel_right_level(double value);
  public:

  // @@protoc_insertion_point(class_scope:flight_panel.EngineData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  double rpm_;
  double rpm_ambiemt_pct_;
  double engine_elapsed_time_;
  double fuel_left_level_;
  double fuel_right_level_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sim_5fdata_2eproto;
};
// -------------------------------------------------------------------

class Instrument PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flight_panel.Instrument) */ {
 public:
  inline Instrument() : Instrument(nullptr) {}
  virtual ~Instrument();

  Instrument(const Instrument& from);
  Instrument(Instrument&& from) noexcept
    : Instrument() {
    *this = ::std::move(from);
  }

  inline Instrument& operator=(const Instrument& from) {
    CopyFrom(from);
    return *this;
  }
  inline Instrument& operator=(Instrument&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Instrument& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Instrument* internal_default_instance() {
    return reinterpret_cast<const Instrument*>(
               &_Instrument_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Instrument& a, Instrument& b) {
    a.Swap(&b);
  }
  inline void Swap(Instrument* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Instrument* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Instrument* New() const final {
    return CreateMaybeMessage<Instrument>(nullptr);
  }

  Instrument* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Instrument>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Instrument& from);
  void MergeFrom(const Instrument& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Instrument* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flight_panel.Instrument";
  }
  protected:
  explicit Instrument(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_sim_5fdata_2eproto);
    return ::descriptor_table_sim_5fdata_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIndicatedAltitudeFieldNumber = 1,
    kKohlsmanSettingHgFieldNumber = 2,
    kVerticalSpeedFieldNumber = 3,
    kPitchAngleFieldNumber = 4,
    kBankAngleFieldNumber = 5,
    kIndicatedAirspeedFieldNumber = 6,
    kTrueAirspeedFieldNumber = 7,
    kMachSpeedFieldNumber = 8,
    kTurnIndicatorRateFieldNumber = 9,
    kTurnCoordinatorBallFieldNumber = 10,
    kHeadingIndicatorDegFieldNumber = 11,
  };
  // double indicated_altitude = 1;
  void clear_indicated_altitude();
  double indicated_altitude() const;
  void set_indicated_altitude(double value);
  private:
  double _internal_indicated_altitude() const;
  void _internal_set_indicated_altitude(double value);
  public:

  // double kohlsman_setting_hg = 2;
  void clear_kohlsman_setting_hg();
  double kohlsman_setting_hg() const;
  void set_kohlsman_setting_hg(double value);
  private:
  double _internal_kohlsman_setting_hg() const;
  void _internal_set_kohlsman_setting_hg(double value);
  public:

  // double vertical_speed = 3;
  void clear_vertical_speed();
  double vertical_speed() const;
  void set_vertical_speed(double value);
  private:
  double _internal_vertical_speed() const;
  void _internal_set_vertical_speed(double value);
  public:

  // double pitch_angle = 4;
  void clear_pitch_angle();
  double pitch_angle() const;
  void set_pitch_angle(double value);
  private:
  double _internal_pitch_angle() const;
  void _internal_set_pitch_angle(double value);
  public:

  // double bank_angle = 5;
  void clear_bank_angle();
  double bank_angle() const;
  void set_bank_angle(double value);
  private:
  double _internal_bank_angle() const;
  void _internal_set_bank_angle(double value);
  public:

  // double indicated_airspeed = 6;
  void clear_indicated_airspeed();
  double indicated_airspeed() const;
  void set_indicated_airspeed(double value);
  private:
  double _internal_indicated_airspeed() const;
  void _internal_set_indicated_airspeed(double value);
  public:

  // double true_airspeed = 7;
  void clear_true_airspeed();
  double true_airspeed() const;
  void set_true_airspeed(double value);
  private:
  double _internal_true_airspeed() const;
  void _internal_set_true_airspeed(double value);
  public:

  // double mach_speed = 8;
  void clear_mach_speed();
  double mach_speed() const;
  void set_mach_speed(double value);
  private:
  double _internal_mach_speed() const;
  void _internal_set_mach_speed(double value);
  public:

  // double turn_indicator_rate = 9;
  void clear_turn_indicator_rate();
  double turn_indicator_rate() const;
  void set_turn_indicator_rate(double value);
  private:
  double _internal_turn_indicator_rate() const;
  void _internal_set_turn_indicator_rate(double value);
  public:

  // double turn_coordinator_ball = 10;
  void clear_turn_coordinator_ball();
  double turn_coordinator_ball() const;
  void set_turn_coordinator_ball(double value);
  private:
  double _internal_turn_coordinator_ball() const;
  void _internal_set_turn_coordinator_ball(double value);
  public:

  // double heading_indicator_deg = 11;
  void clear_heading_indicator_deg();
  double heading_indicator_deg() const;
  void set_heading_indicator_deg(double value);
  private:
  double _internal_heading_indicator_deg() const;
  void _internal_set_heading_indicator_deg(double value);
  public:

  // @@protoc_insertion_point(class_scope:flight_panel.Instrument)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  double indicated_altitude_;
  double kohlsman_setting_hg_;
  double vertical_speed_;
  double pitch_angle_;
  double bank_angle_;
  double indicated_airspeed_;
  double true_airspeed_;
  double mach_speed_;
  double turn_indicator_rate_;
  double turn_coordinator_ball_;
  double heading_indicator_deg_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sim_5fdata_2eproto;
};
// -------------------------------------------------------------------

class AircraftControls PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flight_panel.AircraftControls) */ {
 public:
  inline AircraftControls() : AircraftControls(nullptr) {}
  virtual ~AircraftControls();

  AircraftControls(const AircraftControls& from);
  AircraftControls(AircraftControls&& from) noexcept
    : AircraftControls() {
    *this = ::std::move(from);
  }

  inline AircraftControls& operator=(const AircraftControls& from) {
    CopyFrom(from);
    return *this;
  }
  inline AircraftControls& operator=(AircraftControls&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AircraftControls& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AircraftControls* internal_default_instance() {
    return reinterpret_cast<const AircraftControls*>(
               &_AircraftControls_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(AircraftControls& a, AircraftControls& b) {
    a.Swap(&b);
  }
  inline void Swap(AircraftControls* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AircraftControls* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AircraftControls* New() const final {
    return CreateMaybeMessage<AircraftControls>(nullptr);
  }

  AircraftControls* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AircraftControls>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AircraftControls& from);
  void MergeFrom(const AircraftControls& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AircraftControls* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flight_panel.AircraftControls";
  }
  protected:
  explicit AircraftControls(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_sim_5fdata_2eproto);
    return ::descriptor_table_sim_5fdata_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kElevatorTrimIndicatorFieldNumber = 1,
    kFlapsCountFieldNumber = 2,
    kFlapsPosFieldNumber = 3,
  };
  // double elevator_trim_indicator = 1;
  void clear_elevator_trim_indicator();
  double elevator_trim_indicator() const;
  void set_elevator_trim_indicator(double value);
  private:
  double _internal_elevator_trim_indicator() const;
  void _internal_set_elevator_trim_indicator(double value);
  public:

  // int32 flaps_count = 2;
  void clear_flaps_count();
  ::PROTOBUF_NAMESPACE_ID::int32 flaps_count() const;
  void set_flaps_count(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_flaps_count() const;
  void _internal_set_flaps_count(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 flaps_pos = 3;
  void clear_flaps_pos();
  ::PROTOBUF_NAMESPACE_ID::int32 flaps_pos() const;
  void set_flaps_pos(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_flaps_pos() const;
  void _internal_set_flaps_pos(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:flight_panel.AircraftControls)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  double elevator_trim_indicator_;
  ::PROTOBUF_NAMESPACE_ID::int32 flaps_count_;
  ::PROTOBUF_NAMESPACE_ID::int32 flaps_pos_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sim_5fdata_2eproto;
};
// -------------------------------------------------------------------

class GameData PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flight_panel.GameData) */ {
 public:
  inline GameData() : GameData(nullptr) {}
  virtual ~GameData();

  GameData(const GameData& from);
  GameData(GameData&& from) noexcept
    : GameData() {
    *this = ::std::move(from);
  }

  inline GameData& operator=(const GameData& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameData& operator=(GameData&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GameData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GameData* internal_default_instance() {
    return reinterpret_cast<const GameData*>(
               &_GameData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(GameData& a, GameData& b) {
    a.Swap(&b);
  }
  inline void Swap(GameData* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GameData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GameData* New() const final {
    return CreateMaybeMessage<GameData>(nullptr);
  }

  GameData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GameData>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GameData& from);
  void MergeFrom(const GameData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flight_panel.GameData";
  }
  protected:
  explicit GameData(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_sim_5fdata_2eproto);
    return ::descriptor_table_sim_5fdata_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConnectedFieldNumber = 1,
  };
  // bool connected = 1;
  void clear_connected();
  bool connected() const;
  void set_connected(bool value);
  private:
  bool _internal_connected() const;
  void _internal_set_connected(bool value);
  public:

  // @@protoc_insertion_point(class_scope:flight_panel.GameData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool connected_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sim_5fdata_2eproto;
};
// -------------------------------------------------------------------

class NavigationSystem PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flight_panel.NavigationSystem) */ {
 public:
  inline NavigationSystem() : NavigationSystem(nullptr) {}
  virtual ~NavigationSystem();

  NavigationSystem(const NavigationSystem& from);
  NavigationSystem(NavigationSystem&& from) noexcept
    : NavigationSystem() {
    *this = ::std::move(from);
  }

  inline NavigationSystem& operator=(const NavigationSystem& from) {
    CopyFrom(from);
    return *this;
  }
  inline NavigationSystem& operator=(NavigationSystem&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const NavigationSystem& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NavigationSystem* internal_default_instance() {
    return reinterpret_cast<const NavigationSystem*>(
               &_NavigationSystem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(NavigationSystem& a, NavigationSystem& b) {
    a.Swap(&b);
  }
  inline void Swap(NavigationSystem* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NavigationSystem* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline NavigationSystem* New() const final {
    return CreateMaybeMessage<NavigationSystem>(nullptr);
  }

  NavigationSystem* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NavigationSystem>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const NavigationSystem& from);
  void MergeFrom(const NavigationSystem& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NavigationSystem* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flight_panel.NavigationSystem";
  }
  protected:
  explicit NavigationSystem(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_sim_5fdata_2eproto);
    return ::descriptor_table_sim_5fdata_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef NavigationSystem_NavSource NavSource;
  static constexpr NavSource NAV_UNKNOWN =
    NavigationSystem_NavSource_NAV_UNKNOWN;
  static constexpr NavSource NAV_SOURCE_1 =
    NavigationSystem_NavSource_NAV_SOURCE_1;
  static constexpr NavSource NAV_SOURCE_2 =
    NavigationSystem_NavSource_NAV_SOURCE_2;
  static constexpr NavSource NAV_FMS =
    NavigationSystem_NavSource_NAV_FMS;
  static inline bool NavSource_IsValid(int value) {
    return NavigationSystem_NavSource_IsValid(value);
  }
  static constexpr NavSource NavSource_MIN =
    NavigationSystem_NavSource_NavSource_MIN;
  static constexpr NavSource NavSource_MAX =
    NavigationSystem_NavSource_NavSource_MAX;
  static constexpr int NavSource_ARRAYSIZE =
    NavigationSystem_NavSource_NavSource_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  NavSource_descriptor() {
    return NavigationSystem_NavSource_descriptor();
  }
  template<typename T>
  static inline const std::string& NavSource_Name(T enum_t_value) {
    static_assert(::std::is_same<T, NavSource>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function NavSource_Name.");
    return NavigationSystem_NavSource_Name(enum_t_value);
  }
  static inline bool NavSource_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      NavSource* value) {
    return NavigationSystem_NavSource_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kNextWaypointNameFieldNumber = 20,
    kLastWaypointNameFieldNumber = 21,
    kHsi1FieldNumber = 2,
    kHsi2FieldNumber = 3,
    kActiveNavSourceFieldNumber = 1,
    kNextWaypointDistanceFieldNumber = 19,
  };
  // string next_waypoint_name = 20;
  void clear_next_waypoint_name();
  const std::string& next_waypoint_name() const;
  void set_next_waypoint_name(const std::string& value);
  void set_next_waypoint_name(std::string&& value);
  void set_next_waypoint_name(const char* value);
  void set_next_waypoint_name(const char* value, size_t size);
  std::string* mutable_next_waypoint_name();
  std::string* release_next_waypoint_name();
  void set_allocated_next_waypoint_name(std::string* next_waypoint_name);
  private:
  const std::string& _internal_next_waypoint_name() const;
  void _internal_set_next_waypoint_name(const std::string& value);
  std::string* _internal_mutable_next_waypoint_name();
  public:

  // string last_waypoint_name = 21;
  void clear_last_waypoint_name();
  const std::string& last_waypoint_name() const;
  void set_last_waypoint_name(const std::string& value);
  void set_last_waypoint_name(std::string&& value);
  void set_last_waypoint_name(const char* value);
  void set_last_waypoint_name(const char* value, size_t size);
  std::string* mutable_last_waypoint_name();
  std::string* release_last_waypoint_name();
  void set_allocated_last_waypoint_name(std::string* last_waypoint_name);
  private:
  const std::string& _internal_last_waypoint_name() const;
  void _internal_set_last_waypoint_name(const std::string& value);
  std::string* _internal_mutable_last_waypoint_name();
  public:

  // .flight_panel.HorizontalSituationIndicator hsi_1 = 2;
  bool has_hsi_1() const;
  private:
  bool _internal_has_hsi_1() const;
  public:
  void clear_hsi_1();
  const ::flight_panel::HorizontalSituationIndicator& hsi_1() const;
  ::flight_panel::HorizontalSituationIndicator* release_hsi_1();
  ::flight_panel::HorizontalSituationIndicator* mutable_hsi_1();
  void set_allocated_hsi_1(::flight_panel::HorizontalSituationIndicator* hsi_1);
  private:
  const ::flight_panel::HorizontalSituationIndicator& _internal_hsi_1() const;
  ::flight_panel::HorizontalSituationIndicator* _internal_mutable_hsi_1();
  public:
  void unsafe_arena_set_allocated_hsi_1(
      ::flight_panel::HorizontalSituationIndicator* hsi_1);
  ::flight_panel::HorizontalSituationIndicator* unsafe_arena_release_hsi_1();

  // .flight_panel.HorizontalSituationIndicator hsi_2 = 3;
  bool has_hsi_2() const;
  private:
  bool _internal_has_hsi_2() const;
  public:
  void clear_hsi_2();
  const ::flight_panel::HorizontalSituationIndicator& hsi_2() const;
  ::flight_panel::HorizontalSituationIndicator* release_hsi_2();
  ::flight_panel::HorizontalSituationIndicator* mutable_hsi_2();
  void set_allocated_hsi_2(::flight_panel::HorizontalSituationIndicator* hsi_2);
  private:
  const ::flight_panel::HorizontalSituationIndicator& _internal_hsi_2() const;
  ::flight_panel::HorizontalSituationIndicator* _internal_mutable_hsi_2();
  public:
  void unsafe_arena_set_allocated_hsi_2(
      ::flight_panel::HorizontalSituationIndicator* hsi_2);
  ::flight_panel::HorizontalSituationIndicator* unsafe_arena_release_hsi_2();

  // .flight_panel.NavigationSystem.NavSource active_nav_source = 1;
  void clear_active_nav_source();
  ::flight_panel::NavigationSystem_NavSource active_nav_source() const;
  void set_active_nav_source(::flight_panel::NavigationSystem_NavSource value);
  private:
  ::flight_panel::NavigationSystem_NavSource _internal_active_nav_source() const;
  void _internal_set_active_nav_source(::flight_panel::NavigationSystem_NavSource value);
  public:

  // double next_waypoint_distance = 19;
  void clear_next_waypoint_distance();
  double next_waypoint_distance() const;
  void set_next_waypoint_distance(double value);
  private:
  double _internal_next_waypoint_distance() const;
  void _internal_set_next_waypoint_distance(double value);
  public:

  // @@protoc_insertion_point(class_scope:flight_panel.NavigationSystem)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr next_waypoint_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr last_waypoint_name_;
  ::flight_panel::HorizontalSituationIndicator* hsi_1_;
  ::flight_panel::HorizontalSituationIndicator* hsi_2_;
  int active_nav_source_;
  double next_waypoint_distance_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sim_5fdata_2eproto;
};
// -------------------------------------------------------------------

class HorizontalSituationIndicator PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flight_panel.HorizontalSituationIndicator) */ {
 public:
  inline HorizontalSituationIndicator() : HorizontalSituationIndicator(nullptr) {}
  virtual ~HorizontalSituationIndicator();

  HorizontalSituationIndicator(const HorizontalSituationIndicator& from);
  HorizontalSituationIndicator(HorizontalSituationIndicator&& from) noexcept
    : HorizontalSituationIndicator() {
    *this = ::std::move(from);
  }

  inline HorizontalSituationIndicator& operator=(const HorizontalSituationIndicator& from) {
    CopyFrom(from);
    return *this;
  }
  inline HorizontalSituationIndicator& operator=(HorizontalSituationIndicator&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const HorizontalSituationIndicator& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HorizontalSituationIndicator* internal_default_instance() {
    return reinterpret_cast<const HorizontalSituationIndicator*>(
               &_HorizontalSituationIndicator_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(HorizontalSituationIndicator& a, HorizontalSituationIndicator& b) {
    a.Swap(&b);
  }
  inline void Swap(HorizontalSituationIndicator* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HorizontalSituationIndicator* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline HorizontalSituationIndicator* New() const final {
    return CreateMaybeMessage<HorizontalSituationIndicator>(nullptr);
  }

  HorizontalSituationIndicator* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<HorizontalSituationIndicator>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const HorizontalSituationIndicator& from);
  void MergeFrom(const HorizontalSituationIndicator& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HorizontalSituationIndicator* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flight_panel.HorizontalSituationIndicator";
  }
  protected:
  explicit HorizontalSituationIndicator(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_sim_5fdata_2eproto);
    return ::descriptor_table_sim_5fdata_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCourseFieldNumber = 1,
  };
  // double course = 1;
  void clear_course();
  double course() const;
  void set_course(double value);
  private:
  double _internal_course() const;
  void _internal_set_course(double value);
  public:

  // @@protoc_insertion_point(class_scope:flight_panel.HorizontalSituationIndicator)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  double course_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sim_5fdata_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// SimData

// .flight_panel.AircraftInfo aircraft_info = 1;
inline bool SimData::_internal_has_aircraft_info() const {
  return this != internal_default_instance() && aircraft_info_ != nullptr;
}
inline bool SimData::has_aircraft_info() const {
  return _internal_has_aircraft_info();
}
inline void SimData::clear_aircraft_info() {
  if (GetArena() == nullptr && aircraft_info_ != nullptr) {
    delete aircraft_info_;
  }
  aircraft_info_ = nullptr;
}
inline const ::flight_panel::AircraftInfo& SimData::_internal_aircraft_info() const {
  const ::flight_panel::AircraftInfo* p = aircraft_info_;
  return p != nullptr ? *p : *reinterpret_cast<const ::flight_panel::AircraftInfo*>(
      &::flight_panel::_AircraftInfo_default_instance_);
}
inline const ::flight_panel::AircraftInfo& SimData::aircraft_info() const {
  // @@protoc_insertion_point(field_get:flight_panel.SimData.aircraft_info)
  return _internal_aircraft_info();
}
inline void SimData::unsafe_arena_set_allocated_aircraft_info(
    ::flight_panel::AircraftInfo* aircraft_info) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(aircraft_info_);
  }
  aircraft_info_ = aircraft_info;
  if (aircraft_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flight_panel.SimData.aircraft_info)
}
inline ::flight_panel::AircraftInfo* SimData::release_aircraft_info() {
  
  ::flight_panel::AircraftInfo* temp = aircraft_info_;
  aircraft_info_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::flight_panel::AircraftInfo* SimData::unsafe_arena_release_aircraft_info() {
  // @@protoc_insertion_point(field_release:flight_panel.SimData.aircraft_info)
  
  ::flight_panel::AircraftInfo* temp = aircraft_info_;
  aircraft_info_ = nullptr;
  return temp;
}
inline ::flight_panel::AircraftInfo* SimData::_internal_mutable_aircraft_info() {
  
  if (aircraft_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::flight_panel::AircraftInfo>(GetArena());
    aircraft_info_ = p;
  }
  return aircraft_info_;
}
inline ::flight_panel::AircraftInfo* SimData::mutable_aircraft_info() {
  // @@protoc_insertion_point(field_mutable:flight_panel.SimData.aircraft_info)
  return _internal_mutable_aircraft_info();
}
inline void SimData::set_allocated_aircraft_info(::flight_panel::AircraftInfo* aircraft_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete aircraft_info_;
  }
  if (aircraft_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(aircraft_info);
    if (message_arena != submessage_arena) {
      aircraft_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, aircraft_info, submessage_arena);
    }
    
  } else {
    
  }
  aircraft_info_ = aircraft_info;
  // @@protoc_insertion_point(field_set_allocated:flight_panel.SimData.aircraft_info)
}

// .flight_panel.Avionics avionics = 2;
inline bool SimData::_internal_has_avionics() const {
  return this != internal_default_instance() && avionics_ != nullptr;
}
inline bool SimData::has_avionics() const {
  return _internal_has_avionics();
}
inline void SimData::clear_avionics() {
  if (GetArena() == nullptr && avionics_ != nullptr) {
    delete avionics_;
  }
  avionics_ = nullptr;
}
inline const ::flight_panel::Avionics& SimData::_internal_avionics() const {
  const ::flight_panel::Avionics* p = avionics_;
  return p != nullptr ? *p : *reinterpret_cast<const ::flight_panel::Avionics*>(
      &::flight_panel::_Avionics_default_instance_);
}
inline const ::flight_panel::Avionics& SimData::avionics() const {
  // @@protoc_insertion_point(field_get:flight_panel.SimData.avionics)
  return _internal_avionics();
}
inline void SimData::unsafe_arena_set_allocated_avionics(
    ::flight_panel::Avionics* avionics) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(avionics_);
  }
  avionics_ = avionics;
  if (avionics) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flight_panel.SimData.avionics)
}
inline ::flight_panel::Avionics* SimData::release_avionics() {
  
  ::flight_panel::Avionics* temp = avionics_;
  avionics_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::flight_panel::Avionics* SimData::unsafe_arena_release_avionics() {
  // @@protoc_insertion_point(field_release:flight_panel.SimData.avionics)
  
  ::flight_panel::Avionics* temp = avionics_;
  avionics_ = nullptr;
  return temp;
}
inline ::flight_panel::Avionics* SimData::_internal_mutable_avionics() {
  
  if (avionics_ == nullptr) {
    auto* p = CreateMaybeMessage<::flight_panel::Avionics>(GetArena());
    avionics_ = p;
  }
  return avionics_;
}
inline ::flight_panel::Avionics* SimData::mutable_avionics() {
  // @@protoc_insertion_point(field_mutable:flight_panel.SimData.avionics)
  return _internal_mutable_avionics();
}
inline void SimData::set_allocated_avionics(::flight_panel::Avionics* avionics) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete avionics_;
  }
  if (avionics) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(avionics);
    if (message_arena != submessage_arena) {
      avionics = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, avionics, submessage_arena);
    }
    
  } else {
    
  }
  avionics_ = avionics;
  // @@protoc_insertion_point(field_set_allocated:flight_panel.SimData.avionics)
}

// .flight_panel.AircraftMiscSystem aircraft_misc_data = 3;
inline bool SimData::_internal_has_aircraft_misc_data() const {
  return this != internal_default_instance() && aircraft_misc_data_ != nullptr;
}
inline bool SimData::has_aircraft_misc_data() const {
  return _internal_has_aircraft_misc_data();
}
inline void SimData::clear_aircraft_misc_data() {
  if (GetArena() == nullptr && aircraft_misc_data_ != nullptr) {
    delete aircraft_misc_data_;
  }
  aircraft_misc_data_ = nullptr;
}
inline const ::flight_panel::AircraftMiscSystem& SimData::_internal_aircraft_misc_data() const {
  const ::flight_panel::AircraftMiscSystem* p = aircraft_misc_data_;
  return p != nullptr ? *p : *reinterpret_cast<const ::flight_panel::AircraftMiscSystem*>(
      &::flight_panel::_AircraftMiscSystem_default_instance_);
}
inline const ::flight_panel::AircraftMiscSystem& SimData::aircraft_misc_data() const {
  // @@protoc_insertion_point(field_get:flight_panel.SimData.aircraft_misc_data)
  return _internal_aircraft_misc_data();
}
inline void SimData::unsafe_arena_set_allocated_aircraft_misc_data(
    ::flight_panel::AircraftMiscSystem* aircraft_misc_data) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(aircraft_misc_data_);
  }
  aircraft_misc_data_ = aircraft_misc_data;
  if (aircraft_misc_data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flight_panel.SimData.aircraft_misc_data)
}
inline ::flight_panel::AircraftMiscSystem* SimData::release_aircraft_misc_data() {
  
  ::flight_panel::AircraftMiscSystem* temp = aircraft_misc_data_;
  aircraft_misc_data_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::flight_panel::AircraftMiscSystem* SimData::unsafe_arena_release_aircraft_misc_data() {
  // @@protoc_insertion_point(field_release:flight_panel.SimData.aircraft_misc_data)
  
  ::flight_panel::AircraftMiscSystem* temp = aircraft_misc_data_;
  aircraft_misc_data_ = nullptr;
  return temp;
}
inline ::flight_panel::AircraftMiscSystem* SimData::_internal_mutable_aircraft_misc_data() {
  
  if (aircraft_misc_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::flight_panel::AircraftMiscSystem>(GetArena());
    aircraft_misc_data_ = p;
  }
  return aircraft_misc_data_;
}
inline ::flight_panel::AircraftMiscSystem* SimData::mutable_aircraft_misc_data() {
  // @@protoc_insertion_point(field_mutable:flight_panel.SimData.aircraft_misc_data)
  return _internal_mutable_aircraft_misc_data();
}
inline void SimData::set_allocated_aircraft_misc_data(::flight_panel::AircraftMiscSystem* aircraft_misc_data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete aircraft_misc_data_;
  }
  if (aircraft_misc_data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(aircraft_misc_data);
    if (message_arena != submessage_arena) {
      aircraft_misc_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, aircraft_misc_data, submessage_arena);
    }
    
  } else {
    
  }
  aircraft_misc_data_ = aircraft_misc_data;
  // @@protoc_insertion_point(field_set_allocated:flight_panel.SimData.aircraft_misc_data)
}

// .flight_panel.EngineData engine_data = 4;
inline bool SimData::_internal_has_engine_data() const {
  return this != internal_default_instance() && engine_data_ != nullptr;
}
inline bool SimData::has_engine_data() const {
  return _internal_has_engine_data();
}
inline void SimData::clear_engine_data() {
  if (GetArena() == nullptr && engine_data_ != nullptr) {
    delete engine_data_;
  }
  engine_data_ = nullptr;
}
inline const ::flight_panel::EngineData& SimData::_internal_engine_data() const {
  const ::flight_panel::EngineData* p = engine_data_;
  return p != nullptr ? *p : *reinterpret_cast<const ::flight_panel::EngineData*>(
      &::flight_panel::_EngineData_default_instance_);
}
inline const ::flight_panel::EngineData& SimData::engine_data() const {
  // @@protoc_insertion_point(field_get:flight_panel.SimData.engine_data)
  return _internal_engine_data();
}
inline void SimData::unsafe_arena_set_allocated_engine_data(
    ::flight_panel::EngineData* engine_data) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(engine_data_);
  }
  engine_data_ = engine_data;
  if (engine_data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flight_panel.SimData.engine_data)
}
inline ::flight_panel::EngineData* SimData::release_engine_data() {
  
  ::flight_panel::EngineData* temp = engine_data_;
  engine_data_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::flight_panel::EngineData* SimData::unsafe_arena_release_engine_data() {
  // @@protoc_insertion_point(field_release:flight_panel.SimData.engine_data)
  
  ::flight_panel::EngineData* temp = engine_data_;
  engine_data_ = nullptr;
  return temp;
}
inline ::flight_panel::EngineData* SimData::_internal_mutable_engine_data() {
  
  if (engine_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::flight_panel::EngineData>(GetArena());
    engine_data_ = p;
  }
  return engine_data_;
}
inline ::flight_panel::EngineData* SimData::mutable_engine_data() {
  // @@protoc_insertion_point(field_mutable:flight_panel.SimData.engine_data)
  return _internal_mutable_engine_data();
}
inline void SimData::set_allocated_engine_data(::flight_panel::EngineData* engine_data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete engine_data_;
  }
  if (engine_data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(engine_data);
    if (message_arena != submessage_arena) {
      engine_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, engine_data, submessage_arena);
    }
    
  } else {
    
  }
  engine_data_ = engine_data;
  // @@protoc_insertion_point(field_set_allocated:flight_panel.SimData.engine_data)
}

// .flight_panel.Instrument instruments = 5;
inline bool SimData::_internal_has_instruments() const {
  return this != internal_default_instance() && instruments_ != nullptr;
}
inline bool SimData::has_instruments() const {
  return _internal_has_instruments();
}
inline void SimData::clear_instruments() {
  if (GetArena() == nullptr && instruments_ != nullptr) {
    delete instruments_;
  }
  instruments_ = nullptr;
}
inline const ::flight_panel::Instrument& SimData::_internal_instruments() const {
  const ::flight_panel::Instrument* p = instruments_;
  return p != nullptr ? *p : *reinterpret_cast<const ::flight_panel::Instrument*>(
      &::flight_panel::_Instrument_default_instance_);
}
inline const ::flight_panel::Instrument& SimData::instruments() const {
  // @@protoc_insertion_point(field_get:flight_panel.SimData.instruments)
  return _internal_instruments();
}
inline void SimData::unsafe_arena_set_allocated_instruments(
    ::flight_panel::Instrument* instruments) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(instruments_);
  }
  instruments_ = instruments;
  if (instruments) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flight_panel.SimData.instruments)
}
inline ::flight_panel::Instrument* SimData::release_instruments() {
  
  ::flight_panel::Instrument* temp = instruments_;
  instruments_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::flight_panel::Instrument* SimData::unsafe_arena_release_instruments() {
  // @@protoc_insertion_point(field_release:flight_panel.SimData.instruments)
  
  ::flight_panel::Instrument* temp = instruments_;
  instruments_ = nullptr;
  return temp;
}
inline ::flight_panel::Instrument* SimData::_internal_mutable_instruments() {
  
  if (instruments_ == nullptr) {
    auto* p = CreateMaybeMessage<::flight_panel::Instrument>(GetArena());
    instruments_ = p;
  }
  return instruments_;
}
inline ::flight_panel::Instrument* SimData::mutable_instruments() {
  // @@protoc_insertion_point(field_mutable:flight_panel.SimData.instruments)
  return _internal_mutable_instruments();
}
inline void SimData::set_allocated_instruments(::flight_panel::Instrument* instruments) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete instruments_;
  }
  if (instruments) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(instruments);
    if (message_arena != submessage_arena) {
      instruments = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, instruments, submessage_arena);
    }
    
  } else {
    
  }
  instruments_ = instruments;
  // @@protoc_insertion_point(field_set_allocated:flight_panel.SimData.instruments)
}

// .flight_panel.AircraftControls aircraft_controls = 6;
inline bool SimData::_internal_has_aircraft_controls() const {
  return this != internal_default_instance() && aircraft_controls_ != nullptr;
}
inline bool SimData::has_aircraft_controls() const {
  return _internal_has_aircraft_controls();
}
inline void SimData::clear_aircraft_controls() {
  if (GetArena() == nullptr && aircraft_controls_ != nullptr) {
    delete aircraft_controls_;
  }
  aircraft_controls_ = nullptr;
}
inline const ::flight_panel::AircraftControls& SimData::_internal_aircraft_controls() const {
  const ::flight_panel::AircraftControls* p = aircraft_controls_;
  return p != nullptr ? *p : *reinterpret_cast<const ::flight_panel::AircraftControls*>(
      &::flight_panel::_AircraftControls_default_instance_);
}
inline const ::flight_panel::AircraftControls& SimData::aircraft_controls() const {
  // @@protoc_insertion_point(field_get:flight_panel.SimData.aircraft_controls)
  return _internal_aircraft_controls();
}
inline void SimData::unsafe_arena_set_allocated_aircraft_controls(
    ::flight_panel::AircraftControls* aircraft_controls) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(aircraft_controls_);
  }
  aircraft_controls_ = aircraft_controls;
  if (aircraft_controls) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flight_panel.SimData.aircraft_controls)
}
inline ::flight_panel::AircraftControls* SimData::release_aircraft_controls() {
  
  ::flight_panel::AircraftControls* temp = aircraft_controls_;
  aircraft_controls_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::flight_panel::AircraftControls* SimData::unsafe_arena_release_aircraft_controls() {
  // @@protoc_insertion_point(field_release:flight_panel.SimData.aircraft_controls)
  
  ::flight_panel::AircraftControls* temp = aircraft_controls_;
  aircraft_controls_ = nullptr;
  return temp;
}
inline ::flight_panel::AircraftControls* SimData::_internal_mutable_aircraft_controls() {
  
  if (aircraft_controls_ == nullptr) {
    auto* p = CreateMaybeMessage<::flight_panel::AircraftControls>(GetArena());
    aircraft_controls_ = p;
  }
  return aircraft_controls_;
}
inline ::flight_panel::AircraftControls* SimData::mutable_aircraft_controls() {
  // @@protoc_insertion_point(field_mutable:flight_panel.SimData.aircraft_controls)
  return _internal_mutable_aircraft_controls();
}
inline void SimData::set_allocated_aircraft_controls(::flight_panel::AircraftControls* aircraft_controls) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete aircraft_controls_;
  }
  if (aircraft_controls) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(aircraft_controls);
    if (message_arena != submessage_arena) {
      aircraft_controls = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, aircraft_controls, submessage_arena);
    }
    
  } else {
    
  }
  aircraft_controls_ = aircraft_controls;
  // @@protoc_insertion_point(field_set_allocated:flight_panel.SimData.aircraft_controls)
}

// .flight_panel.GameData game_data = 7;
inline bool SimData::_internal_has_game_data() const {
  return this != internal_default_instance() && game_data_ != nullptr;
}
inline bool SimData::has_game_data() const {
  return _internal_has_game_data();
}
inline void SimData::clear_game_data() {
  if (GetArena() == nullptr && game_data_ != nullptr) {
    delete game_data_;
  }
  game_data_ = nullptr;
}
inline const ::flight_panel::GameData& SimData::_internal_game_data() const {
  const ::flight_panel::GameData* p = game_data_;
  return p != nullptr ? *p : *reinterpret_cast<const ::flight_panel::GameData*>(
      &::flight_panel::_GameData_default_instance_);
}
inline const ::flight_panel::GameData& SimData::game_data() const {
  // @@protoc_insertion_point(field_get:flight_panel.SimData.game_data)
  return _internal_game_data();
}
inline void SimData::unsafe_arena_set_allocated_game_data(
    ::flight_panel::GameData* game_data) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(game_data_);
  }
  game_data_ = game_data;
  if (game_data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flight_panel.SimData.game_data)
}
inline ::flight_panel::GameData* SimData::release_game_data() {
  
  ::flight_panel::GameData* temp = game_data_;
  game_data_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::flight_panel::GameData* SimData::unsafe_arena_release_game_data() {
  // @@protoc_insertion_point(field_release:flight_panel.SimData.game_data)
  
  ::flight_panel::GameData* temp = game_data_;
  game_data_ = nullptr;
  return temp;
}
inline ::flight_panel::GameData* SimData::_internal_mutable_game_data() {
  
  if (game_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::flight_panel::GameData>(GetArena());
    game_data_ = p;
  }
  return game_data_;
}
inline ::flight_panel::GameData* SimData::mutable_game_data() {
  // @@protoc_insertion_point(field_mutable:flight_panel.SimData.game_data)
  return _internal_mutable_game_data();
}
inline void SimData::set_allocated_game_data(::flight_panel::GameData* game_data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete game_data_;
  }
  if (game_data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(game_data);
    if (message_arena != submessage_arena) {
      game_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, game_data, submessage_arena);
    }
    
  } else {
    
  }
  game_data_ = game_data;
  // @@protoc_insertion_point(field_set_allocated:flight_panel.SimData.game_data)
}

// -------------------------------------------------------------------

// AircraftInfo

// string model = 1;
inline void AircraftInfo::clear_model() {
  model_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& AircraftInfo::model() const {
  // @@protoc_insertion_point(field_get:flight_panel.AircraftInfo.model)
  return _internal_model();
}
inline void AircraftInfo::set_model(const std::string& value) {
  _internal_set_model(value);
  // @@protoc_insertion_point(field_set:flight_panel.AircraftInfo.model)
}
inline std::string* AircraftInfo::mutable_model() {
  // @@protoc_insertion_point(field_mutable:flight_panel.AircraftInfo.model)
  return _internal_mutable_model();
}
inline const std::string& AircraftInfo::_internal_model() const {
  return model_.Get();
}
inline void AircraftInfo::_internal_set_model(const std::string& value) {
  
  model_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void AircraftInfo::set_model(std::string&& value) {
  
  model_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:flight_panel.AircraftInfo.model)
}
inline void AircraftInfo::set_model(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  model_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:flight_panel.AircraftInfo.model)
}
inline void AircraftInfo::set_model(const char* value,
    size_t size) {
  
  model_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:flight_panel.AircraftInfo.model)
}
inline std::string* AircraftInfo::_internal_mutable_model() {
  
  return model_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* AircraftInfo::release_model() {
  // @@protoc_insertion_point(field_release:flight_panel.AircraftInfo.model)
  return model_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void AircraftInfo::set_allocated_model(std::string* model) {
  if (model != nullptr) {
    
  } else {
    
  }
  model_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), model,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:flight_panel.AircraftInfo.model)
}

// string call_sign = 2;
inline void AircraftInfo::clear_call_sign() {
  call_sign_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& AircraftInfo::call_sign() const {
  // @@protoc_insertion_point(field_get:flight_panel.AircraftInfo.call_sign)
  return _internal_call_sign();
}
inline void AircraftInfo::set_call_sign(const std::string& value) {
  _internal_set_call_sign(value);
  // @@protoc_insertion_point(field_set:flight_panel.AircraftInfo.call_sign)
}
inline std::string* AircraftInfo::mutable_call_sign() {
  // @@protoc_insertion_point(field_mutable:flight_panel.AircraftInfo.call_sign)
  return _internal_mutable_call_sign();
}
inline const std::string& AircraftInfo::_internal_call_sign() const {
  return call_sign_.Get();
}
inline void AircraftInfo::_internal_set_call_sign(const std::string& value) {
  
  call_sign_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void AircraftInfo::set_call_sign(std::string&& value) {
  
  call_sign_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:flight_panel.AircraftInfo.call_sign)
}
inline void AircraftInfo::set_call_sign(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  call_sign_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:flight_panel.AircraftInfo.call_sign)
}
inline void AircraftInfo::set_call_sign(const char* value,
    size_t size) {
  
  call_sign_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:flight_panel.AircraftInfo.call_sign)
}
inline std::string* AircraftInfo::_internal_mutable_call_sign() {
  
  return call_sign_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* AircraftInfo::release_call_sign() {
  // @@protoc_insertion_point(field_release:flight_panel.AircraftInfo.call_sign)
  return call_sign_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void AircraftInfo::set_allocated_call_sign(std::string* call_sign) {
  if (call_sign != nullptr) {
    
  } else {
    
  }
  call_sign_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), call_sign,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:flight_panel.AircraftInfo.call_sign)
}

// -------------------------------------------------------------------

// Avionics

// .flight_panel.CourseDeviationIndicator cdi_1 = 1;
inline bool Avionics::_internal_has_cdi_1() const {
  return this != internal_default_instance() && cdi_1_ != nullptr;
}
inline bool Avionics::has_cdi_1() const {
  return _internal_has_cdi_1();
}
inline void Avionics::clear_cdi_1() {
  if (GetArena() == nullptr && cdi_1_ != nullptr) {
    delete cdi_1_;
  }
  cdi_1_ = nullptr;
}
inline const ::flight_panel::CourseDeviationIndicator& Avionics::_internal_cdi_1() const {
  const ::flight_panel::CourseDeviationIndicator* p = cdi_1_;
  return p != nullptr ? *p : *reinterpret_cast<const ::flight_panel::CourseDeviationIndicator*>(
      &::flight_panel::_CourseDeviationIndicator_default_instance_);
}
inline const ::flight_panel::CourseDeviationIndicator& Avionics::cdi_1() const {
  // @@protoc_insertion_point(field_get:flight_panel.Avionics.cdi_1)
  return _internal_cdi_1();
}
inline void Avionics::unsafe_arena_set_allocated_cdi_1(
    ::flight_panel::CourseDeviationIndicator* cdi_1) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(cdi_1_);
  }
  cdi_1_ = cdi_1;
  if (cdi_1) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flight_panel.Avionics.cdi_1)
}
inline ::flight_panel::CourseDeviationIndicator* Avionics::release_cdi_1() {
  
  ::flight_panel::CourseDeviationIndicator* temp = cdi_1_;
  cdi_1_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::flight_panel::CourseDeviationIndicator* Avionics::unsafe_arena_release_cdi_1() {
  // @@protoc_insertion_point(field_release:flight_panel.Avionics.cdi_1)
  
  ::flight_panel::CourseDeviationIndicator* temp = cdi_1_;
  cdi_1_ = nullptr;
  return temp;
}
inline ::flight_panel::CourseDeviationIndicator* Avionics::_internal_mutable_cdi_1() {
  
  if (cdi_1_ == nullptr) {
    auto* p = CreateMaybeMessage<::flight_panel::CourseDeviationIndicator>(GetArena());
    cdi_1_ = p;
  }
  return cdi_1_;
}
inline ::flight_panel::CourseDeviationIndicator* Avionics::mutable_cdi_1() {
  // @@protoc_insertion_point(field_mutable:flight_panel.Avionics.cdi_1)
  return _internal_mutable_cdi_1();
}
inline void Avionics::set_allocated_cdi_1(::flight_panel::CourseDeviationIndicator* cdi_1) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete cdi_1_;
  }
  if (cdi_1) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(cdi_1);
    if (message_arena != submessage_arena) {
      cdi_1 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cdi_1, submessage_arena);
    }
    
  } else {
    
  }
  cdi_1_ = cdi_1;
  // @@protoc_insertion_point(field_set_allocated:flight_panel.Avionics.cdi_1)
}

// .flight_panel.CourseDeviationIndicator cdi_2 = 2;
inline bool Avionics::_internal_has_cdi_2() const {
  return this != internal_default_instance() && cdi_2_ != nullptr;
}
inline bool Avionics::has_cdi_2() const {
  return _internal_has_cdi_2();
}
inline void Avionics::clear_cdi_2() {
  if (GetArena() == nullptr && cdi_2_ != nullptr) {
    delete cdi_2_;
  }
  cdi_2_ = nullptr;
}
inline const ::flight_panel::CourseDeviationIndicator& Avionics::_internal_cdi_2() const {
  const ::flight_panel::CourseDeviationIndicator* p = cdi_2_;
  return p != nullptr ? *p : *reinterpret_cast<const ::flight_panel::CourseDeviationIndicator*>(
      &::flight_panel::_CourseDeviationIndicator_default_instance_);
}
inline const ::flight_panel::CourseDeviationIndicator& Avionics::cdi_2() const {
  // @@protoc_insertion_point(field_get:flight_panel.Avionics.cdi_2)
  return _internal_cdi_2();
}
inline void Avionics::unsafe_arena_set_allocated_cdi_2(
    ::flight_panel::CourseDeviationIndicator* cdi_2) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(cdi_2_);
  }
  cdi_2_ = cdi_2;
  if (cdi_2) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flight_panel.Avionics.cdi_2)
}
inline ::flight_panel::CourseDeviationIndicator* Avionics::release_cdi_2() {
  
  ::flight_panel::CourseDeviationIndicator* temp = cdi_2_;
  cdi_2_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::flight_panel::CourseDeviationIndicator* Avionics::unsafe_arena_release_cdi_2() {
  // @@protoc_insertion_point(field_release:flight_panel.Avionics.cdi_2)
  
  ::flight_panel::CourseDeviationIndicator* temp = cdi_2_;
  cdi_2_ = nullptr;
  return temp;
}
inline ::flight_panel::CourseDeviationIndicator* Avionics::_internal_mutable_cdi_2() {
  
  if (cdi_2_ == nullptr) {
    auto* p = CreateMaybeMessage<::flight_panel::CourseDeviationIndicator>(GetArena());
    cdi_2_ = p;
  }
  return cdi_2_;
}
inline ::flight_panel::CourseDeviationIndicator* Avionics::mutable_cdi_2() {
  // @@protoc_insertion_point(field_mutable:flight_panel.Avionics.cdi_2)
  return _internal_mutable_cdi_2();
}
inline void Avionics::set_allocated_cdi_2(::flight_panel::CourseDeviationIndicator* cdi_2) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete cdi_2_;
  }
  if (cdi_2) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(cdi_2);
    if (message_arena != submessage_arena) {
      cdi_2 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cdi_2, submessage_arena);
    }
    
  } else {
    
  }
  cdi_2_ = cdi_2;
  // @@protoc_insertion_point(field_set_allocated:flight_panel.Avionics.cdi_2)
}

// double adi_radial = 3;
inline void Avionics::clear_adi_radial() {
  adi_radial_ = 0;
}
inline double Avionics::_internal_adi_radial() const {
  return adi_radial_;
}
inline double Avionics::adi_radial() const {
  // @@protoc_insertion_point(field_get:flight_panel.Avionics.adi_radial)
  return _internal_adi_radial();
}
inline void Avionics::_internal_set_adi_radial(double value) {
  
  adi_radial_ = value;
}
inline void Avionics::set_adi_radial(double value) {
  _internal_set_adi_radial(value);
  // @@protoc_insertion_point(field_set:flight_panel.Avionics.adi_radial)
}

// .flight_panel.RadioChannel nav_radio_1 = 4;
inline bool Avionics::_internal_has_nav_radio_1() const {
  return this != internal_default_instance() && nav_radio_1_ != nullptr;
}
inline bool Avionics::has_nav_radio_1() const {
  return _internal_has_nav_radio_1();
}
inline void Avionics::clear_nav_radio_1() {
  if (GetArena() == nullptr && nav_radio_1_ != nullptr) {
    delete nav_radio_1_;
  }
  nav_radio_1_ = nullptr;
}
inline const ::flight_panel::RadioChannel& Avionics::_internal_nav_radio_1() const {
  const ::flight_panel::RadioChannel* p = nav_radio_1_;
  return p != nullptr ? *p : *reinterpret_cast<const ::flight_panel::RadioChannel*>(
      &::flight_panel::_RadioChannel_default_instance_);
}
inline const ::flight_panel::RadioChannel& Avionics::nav_radio_1() const {
  // @@protoc_insertion_point(field_get:flight_panel.Avionics.nav_radio_1)
  return _internal_nav_radio_1();
}
inline void Avionics::unsafe_arena_set_allocated_nav_radio_1(
    ::flight_panel::RadioChannel* nav_radio_1) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(nav_radio_1_);
  }
  nav_radio_1_ = nav_radio_1;
  if (nav_radio_1) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flight_panel.Avionics.nav_radio_1)
}
inline ::flight_panel::RadioChannel* Avionics::release_nav_radio_1() {
  
  ::flight_panel::RadioChannel* temp = nav_radio_1_;
  nav_radio_1_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::flight_panel::RadioChannel* Avionics::unsafe_arena_release_nav_radio_1() {
  // @@protoc_insertion_point(field_release:flight_panel.Avionics.nav_radio_1)
  
  ::flight_panel::RadioChannel* temp = nav_radio_1_;
  nav_radio_1_ = nullptr;
  return temp;
}
inline ::flight_panel::RadioChannel* Avionics::_internal_mutable_nav_radio_1() {
  
  if (nav_radio_1_ == nullptr) {
    auto* p = CreateMaybeMessage<::flight_panel::RadioChannel>(GetArena());
    nav_radio_1_ = p;
  }
  return nav_radio_1_;
}
inline ::flight_panel::RadioChannel* Avionics::mutable_nav_radio_1() {
  // @@protoc_insertion_point(field_mutable:flight_panel.Avionics.nav_radio_1)
  return _internal_mutable_nav_radio_1();
}
inline void Avionics::set_allocated_nav_radio_1(::flight_panel::RadioChannel* nav_radio_1) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete nav_radio_1_;
  }
  if (nav_radio_1) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(nav_radio_1);
    if (message_arena != submessage_arena) {
      nav_radio_1 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, nav_radio_1, submessage_arena);
    }
    
  } else {
    
  }
  nav_radio_1_ = nav_radio_1;
  // @@protoc_insertion_point(field_set_allocated:flight_panel.Avionics.nav_radio_1)
}

// .flight_panel.RadioChannel nav_radio_2 = 5;
inline bool Avionics::_internal_has_nav_radio_2() const {
  return this != internal_default_instance() && nav_radio_2_ != nullptr;
}
inline bool Avionics::has_nav_radio_2() const {
  return _internal_has_nav_radio_2();
}
inline void Avionics::clear_nav_radio_2() {
  if (GetArena() == nullptr && nav_radio_2_ != nullptr) {
    delete nav_radio_2_;
  }
  nav_radio_2_ = nullptr;
}
inline const ::flight_panel::RadioChannel& Avionics::_internal_nav_radio_2() const {
  const ::flight_panel::RadioChannel* p = nav_radio_2_;
  return p != nullptr ? *p : *reinterpret_cast<const ::flight_panel::RadioChannel*>(
      &::flight_panel::_RadioChannel_default_instance_);
}
inline const ::flight_panel::RadioChannel& Avionics::nav_radio_2() const {
  // @@protoc_insertion_point(field_get:flight_panel.Avionics.nav_radio_2)
  return _internal_nav_radio_2();
}
inline void Avionics::unsafe_arena_set_allocated_nav_radio_2(
    ::flight_panel::RadioChannel* nav_radio_2) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(nav_radio_2_);
  }
  nav_radio_2_ = nav_radio_2;
  if (nav_radio_2) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flight_panel.Avionics.nav_radio_2)
}
inline ::flight_panel::RadioChannel* Avionics::release_nav_radio_2() {
  
  ::flight_panel::RadioChannel* temp = nav_radio_2_;
  nav_radio_2_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::flight_panel::RadioChannel* Avionics::unsafe_arena_release_nav_radio_2() {
  // @@protoc_insertion_point(field_release:flight_panel.Avionics.nav_radio_2)
  
  ::flight_panel::RadioChannel* temp = nav_radio_2_;
  nav_radio_2_ = nullptr;
  return temp;
}
inline ::flight_panel::RadioChannel* Avionics::_internal_mutable_nav_radio_2() {
  
  if (nav_radio_2_ == nullptr) {
    auto* p = CreateMaybeMessage<::flight_panel::RadioChannel>(GetArena());
    nav_radio_2_ = p;
  }
  return nav_radio_2_;
}
inline ::flight_panel::RadioChannel* Avionics::mutable_nav_radio_2() {
  // @@protoc_insertion_point(field_mutable:flight_panel.Avionics.nav_radio_2)
  return _internal_mutable_nav_radio_2();
}
inline void Avionics::set_allocated_nav_radio_2(::flight_panel::RadioChannel* nav_radio_2) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete nav_radio_2_;
  }
  if (nav_radio_2) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(nav_radio_2);
    if (message_arena != submessage_arena) {
      nav_radio_2 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, nav_radio_2, submessage_arena);
    }
    
  } else {
    
  }
  nav_radio_2_ = nav_radio_2;
  // @@protoc_insertion_point(field_set_allocated:flight_panel.Avionics.nav_radio_2)
}

// .flight_panel.RadioChannel com_radio_1 = 6;
inline bool Avionics::_internal_has_com_radio_1() const {
  return this != internal_default_instance() && com_radio_1_ != nullptr;
}
inline bool Avionics::has_com_radio_1() const {
  return _internal_has_com_radio_1();
}
inline void Avionics::clear_com_radio_1() {
  if (GetArena() == nullptr && com_radio_1_ != nullptr) {
    delete com_radio_1_;
  }
  com_radio_1_ = nullptr;
}
inline const ::flight_panel::RadioChannel& Avionics::_internal_com_radio_1() const {
  const ::flight_panel::RadioChannel* p = com_radio_1_;
  return p != nullptr ? *p : *reinterpret_cast<const ::flight_panel::RadioChannel*>(
      &::flight_panel::_RadioChannel_default_instance_);
}
inline const ::flight_panel::RadioChannel& Avionics::com_radio_1() const {
  // @@protoc_insertion_point(field_get:flight_panel.Avionics.com_radio_1)
  return _internal_com_radio_1();
}
inline void Avionics::unsafe_arena_set_allocated_com_radio_1(
    ::flight_panel::RadioChannel* com_radio_1) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(com_radio_1_);
  }
  com_radio_1_ = com_radio_1;
  if (com_radio_1) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flight_panel.Avionics.com_radio_1)
}
inline ::flight_panel::RadioChannel* Avionics::release_com_radio_1() {
  
  ::flight_panel::RadioChannel* temp = com_radio_1_;
  com_radio_1_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::flight_panel::RadioChannel* Avionics::unsafe_arena_release_com_radio_1() {
  // @@protoc_insertion_point(field_release:flight_panel.Avionics.com_radio_1)
  
  ::flight_panel::RadioChannel* temp = com_radio_1_;
  com_radio_1_ = nullptr;
  return temp;
}
inline ::flight_panel::RadioChannel* Avionics::_internal_mutable_com_radio_1() {
  
  if (com_radio_1_ == nullptr) {
    auto* p = CreateMaybeMessage<::flight_panel::RadioChannel>(GetArena());
    com_radio_1_ = p;
  }
  return com_radio_1_;
}
inline ::flight_panel::RadioChannel* Avionics::mutable_com_radio_1() {
  // @@protoc_insertion_point(field_mutable:flight_panel.Avionics.com_radio_1)
  return _internal_mutable_com_radio_1();
}
inline void Avionics::set_allocated_com_radio_1(::flight_panel::RadioChannel* com_radio_1) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete com_radio_1_;
  }
  if (com_radio_1) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(com_radio_1);
    if (message_arena != submessage_arena) {
      com_radio_1 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, com_radio_1, submessage_arena);
    }
    
  } else {
    
  }
  com_radio_1_ = com_radio_1;
  // @@protoc_insertion_point(field_set_allocated:flight_panel.Avionics.com_radio_1)
}

// .flight_panel.RadioChannel com_radio_2 = 7;
inline bool Avionics::_internal_has_com_radio_2() const {
  return this != internal_default_instance() && com_radio_2_ != nullptr;
}
inline bool Avionics::has_com_radio_2() const {
  return _internal_has_com_radio_2();
}
inline void Avionics::clear_com_radio_2() {
  if (GetArena() == nullptr && com_radio_2_ != nullptr) {
    delete com_radio_2_;
  }
  com_radio_2_ = nullptr;
}
inline const ::flight_panel::RadioChannel& Avionics::_internal_com_radio_2() const {
  const ::flight_panel::RadioChannel* p = com_radio_2_;
  return p != nullptr ? *p : *reinterpret_cast<const ::flight_panel::RadioChannel*>(
      &::flight_panel::_RadioChannel_default_instance_);
}
inline const ::flight_panel::RadioChannel& Avionics::com_radio_2() const {
  // @@protoc_insertion_point(field_get:flight_panel.Avionics.com_radio_2)
  return _internal_com_radio_2();
}
inline void Avionics::unsafe_arena_set_allocated_com_radio_2(
    ::flight_panel::RadioChannel* com_radio_2) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(com_radio_2_);
  }
  com_radio_2_ = com_radio_2;
  if (com_radio_2) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flight_panel.Avionics.com_radio_2)
}
inline ::flight_panel::RadioChannel* Avionics::release_com_radio_2() {
  
  ::flight_panel::RadioChannel* temp = com_radio_2_;
  com_radio_2_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::flight_panel::RadioChannel* Avionics::unsafe_arena_release_com_radio_2() {
  // @@protoc_insertion_point(field_release:flight_panel.Avionics.com_radio_2)
  
  ::flight_panel::RadioChannel* temp = com_radio_2_;
  com_radio_2_ = nullptr;
  return temp;
}
inline ::flight_panel::RadioChannel* Avionics::_internal_mutable_com_radio_2() {
  
  if (com_radio_2_ == nullptr) {
    auto* p = CreateMaybeMessage<::flight_panel::RadioChannel>(GetArena());
    com_radio_2_ = p;
  }
  return com_radio_2_;
}
inline ::flight_panel::RadioChannel* Avionics::mutable_com_radio_2() {
  // @@protoc_insertion_point(field_mutable:flight_panel.Avionics.com_radio_2)
  return _internal_mutable_com_radio_2();
}
inline void Avionics::set_allocated_com_radio_2(::flight_panel::RadioChannel* com_radio_2) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete com_radio_2_;
  }
  if (com_radio_2) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(com_radio_2);
    if (message_arena != submessage_arena) {
      com_radio_2 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, com_radio_2, submessage_arena);
    }
    
  } else {
    
  }
  com_radio_2_ = com_radio_2;
  // @@protoc_insertion_point(field_set_allocated:flight_panel.Avionics.com_radio_2)
}

// .flight_panel.RadioChannel adf_radio = 8;
inline bool Avionics::_internal_has_adf_radio() const {
  return this != internal_default_instance() && adf_radio_ != nullptr;
}
inline bool Avionics::has_adf_radio() const {
  return _internal_has_adf_radio();
}
inline void Avionics::clear_adf_radio() {
  if (GetArena() == nullptr && adf_radio_ != nullptr) {
    delete adf_radio_;
  }
  adf_radio_ = nullptr;
}
inline const ::flight_panel::RadioChannel& Avionics::_internal_adf_radio() const {
  const ::flight_panel::RadioChannel* p = adf_radio_;
  return p != nullptr ? *p : *reinterpret_cast<const ::flight_panel::RadioChannel*>(
      &::flight_panel::_RadioChannel_default_instance_);
}
inline const ::flight_panel::RadioChannel& Avionics::adf_radio() const {
  // @@protoc_insertion_point(field_get:flight_panel.Avionics.adf_radio)
  return _internal_adf_radio();
}
inline void Avionics::unsafe_arena_set_allocated_adf_radio(
    ::flight_panel::RadioChannel* adf_radio) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(adf_radio_);
  }
  adf_radio_ = adf_radio;
  if (adf_radio) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flight_panel.Avionics.adf_radio)
}
inline ::flight_panel::RadioChannel* Avionics::release_adf_radio() {
  
  ::flight_panel::RadioChannel* temp = adf_radio_;
  adf_radio_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::flight_panel::RadioChannel* Avionics::unsafe_arena_release_adf_radio() {
  // @@protoc_insertion_point(field_release:flight_panel.Avionics.adf_radio)
  
  ::flight_panel::RadioChannel* temp = adf_radio_;
  adf_radio_ = nullptr;
  return temp;
}
inline ::flight_panel::RadioChannel* Avionics::_internal_mutable_adf_radio() {
  
  if (adf_radio_ == nullptr) {
    auto* p = CreateMaybeMessage<::flight_panel::RadioChannel>(GetArena());
    adf_radio_ = p;
  }
  return adf_radio_;
}
inline ::flight_panel::RadioChannel* Avionics::mutable_adf_radio() {
  // @@protoc_insertion_point(field_mutable:flight_panel.Avionics.adf_radio)
  return _internal_mutable_adf_radio();
}
inline void Avionics::set_allocated_adf_radio(::flight_panel::RadioChannel* adf_radio) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete adf_radio_;
  }
  if (adf_radio) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(adf_radio);
    if (message_arena != submessage_arena) {
      adf_radio = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, adf_radio, submessage_arena);
    }
    
  } else {
    
  }
  adf_radio_ = adf_radio;
  // @@protoc_insertion_point(field_set_allocated:flight_panel.Avionics.adf_radio)
}

// string transponder_code = 9;
inline void Avionics::clear_transponder_code() {
  transponder_code_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Avionics::transponder_code() const {
  // @@protoc_insertion_point(field_get:flight_panel.Avionics.transponder_code)
  return _internal_transponder_code();
}
inline void Avionics::set_transponder_code(const std::string& value) {
  _internal_set_transponder_code(value);
  // @@protoc_insertion_point(field_set:flight_panel.Avionics.transponder_code)
}
inline std::string* Avionics::mutable_transponder_code() {
  // @@protoc_insertion_point(field_mutable:flight_panel.Avionics.transponder_code)
  return _internal_mutable_transponder_code();
}
inline const std::string& Avionics::_internal_transponder_code() const {
  return transponder_code_.Get();
}
inline void Avionics::_internal_set_transponder_code(const std::string& value) {
  
  transponder_code_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Avionics::set_transponder_code(std::string&& value) {
  
  transponder_code_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:flight_panel.Avionics.transponder_code)
}
inline void Avionics::set_transponder_code(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  transponder_code_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:flight_panel.Avionics.transponder_code)
}
inline void Avionics::set_transponder_code(const char* value,
    size_t size) {
  
  transponder_code_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:flight_panel.Avionics.transponder_code)
}
inline std::string* Avionics::_internal_mutable_transponder_code() {
  
  return transponder_code_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Avionics::release_transponder_code() {
  // @@protoc_insertion_point(field_release:flight_panel.Avionics.transponder_code)
  return transponder_code_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Avionics::set_allocated_transponder_code(std::string* transponder_code) {
  if (transponder_code != nullptr) {
    
  } else {
    
  }
  transponder_code_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), transponder_code,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:flight_panel.Avionics.transponder_code)
}

// -------------------------------------------------------------------

// RadioChannel

// double active_freq = 1;
inline void RadioChannel::clear_active_freq() {
  active_freq_ = 0;
}
inline double RadioChannel::_internal_active_freq() const {
  return active_freq_;
}
inline double RadioChannel::active_freq() const {
  // @@protoc_insertion_point(field_get:flight_panel.RadioChannel.active_freq)
  return _internal_active_freq();
}
inline void RadioChannel::_internal_set_active_freq(double value) {
  
  active_freq_ = value;
}
inline void RadioChannel::set_active_freq(double value) {
  _internal_set_active_freq(value);
  // @@protoc_insertion_point(field_set:flight_panel.RadioChannel.active_freq)
}

// double standby_freq = 2;
inline void RadioChannel::clear_standby_freq() {
  standby_freq_ = 0;
}
inline double RadioChannel::_internal_standby_freq() const {
  return standby_freq_;
}
inline double RadioChannel::standby_freq() const {
  // @@protoc_insertion_point(field_get:flight_panel.RadioChannel.standby_freq)
  return _internal_standby_freq();
}
inline void RadioChannel::_internal_set_standby_freq(double value) {
  
  standby_freq_ = value;
}
inline void RadioChannel::set_standby_freq(double value) {
  _internal_set_standby_freq(value);
  // @@protoc_insertion_point(field_set:flight_panel.RadioChannel.standby_freq)
}

// -------------------------------------------------------------------

// CourseDeviationIndicator

// double obs_deg = 1;
inline void CourseDeviationIndicator::clear_obs_deg() {
  obs_deg_ = 0;
}
inline double CourseDeviationIndicator::_internal_obs_deg() const {
  return obs_deg_;
}
inline double CourseDeviationIndicator::obs_deg() const {
  // @@protoc_insertion_point(field_get:flight_panel.CourseDeviationIndicator.obs_deg)
  return _internal_obs_deg();
}
inline void CourseDeviationIndicator::_internal_set_obs_deg(double value) {
  
  obs_deg_ = value;
}
inline void CourseDeviationIndicator::set_obs_deg(double value) {
  _internal_set_obs_deg(value);
  // @@protoc_insertion_point(field_set:flight_panel.CourseDeviationIndicator.obs_deg)
}

// double radial_error = 2;
inline void CourseDeviationIndicator::clear_radial_error() {
  radial_error_ = 0;
}
inline double CourseDeviationIndicator::_internal_radial_error() const {
  return radial_error_;
}
inline double CourseDeviationIndicator::radial_error() const {
  // @@protoc_insertion_point(field_get:flight_panel.CourseDeviationIndicator.radial_error)
  return _internal_radial_error();
}
inline void CourseDeviationIndicator::_internal_set_radial_error(double value) {
  
  radial_error_ = value;
}
inline void CourseDeviationIndicator::set_radial_error(double value) {
  _internal_set_radial_error(value);
  // @@protoc_insertion_point(field_set:flight_panel.CourseDeviationIndicator.radial_error)
}

// double glide_slope_error = 3;
inline void CourseDeviationIndicator::clear_glide_slope_error() {
  glide_slope_error_ = 0;
}
inline double CourseDeviationIndicator::_internal_glide_slope_error() const {
  return glide_slope_error_;
}
inline double CourseDeviationIndicator::glide_slope_error() const {
  // @@protoc_insertion_point(field_get:flight_panel.CourseDeviationIndicator.glide_slope_error)
  return _internal_glide_slope_error();
}
inline void CourseDeviationIndicator::_internal_set_glide_slope_error(double value) {
  
  glide_slope_error_ = value;
}
inline void CourseDeviationIndicator::set_glide_slope_error(double value) {
  _internal_set_glide_slope_error(value);
  // @@protoc_insertion_point(field_set:flight_panel.CourseDeviationIndicator.glide_slope_error)
}

// .flight_panel.CourseDeviationIndicator.Direction direction = 4;
inline void CourseDeviationIndicator::clear_direction() {
  direction_ = 0;
}
inline ::flight_panel::CourseDeviationIndicator_Direction CourseDeviationIndicator::_internal_direction() const {
  return static_cast< ::flight_panel::CourseDeviationIndicator_Direction >(direction_);
}
inline ::flight_panel::CourseDeviationIndicator_Direction CourseDeviationIndicator::direction() const {
  // @@protoc_insertion_point(field_get:flight_panel.CourseDeviationIndicator.direction)
  return _internal_direction();
}
inline void CourseDeviationIndicator::_internal_set_direction(::flight_panel::CourseDeviationIndicator_Direction value) {
  
  direction_ = value;
}
inline void CourseDeviationIndicator::set_direction(::flight_panel::CourseDeviationIndicator_Direction value) {
  _internal_set_direction(value);
  // @@protoc_insertion_point(field_set:flight_panel.CourseDeviationIndicator.direction)
}

// bool glisdeslope_flag = 5;
inline void CourseDeviationIndicator::clear_glisdeslope_flag() {
  glisdeslope_flag_ = false;
}
inline bool CourseDeviationIndicator::_internal_glisdeslope_flag() const {
  return glisdeslope_flag_;
}
inline bool CourseDeviationIndicator::glisdeslope_flag() const {
  // @@protoc_insertion_point(field_get:flight_panel.CourseDeviationIndicator.glisdeslope_flag)
  return _internal_glisdeslope_flag();
}
inline void CourseDeviationIndicator::_internal_set_glisdeslope_flag(bool value) {
  
  glisdeslope_flag_ = value;
}
inline void CourseDeviationIndicator::set_glisdeslope_flag(bool value) {
  _internal_set_glisdeslope_flag(value);
  // @@protoc_insertion_point(field_set:flight_panel.CourseDeviationIndicator.glisdeslope_flag)
}

// -------------------------------------------------------------------

// AircraftMiscSystem

// double battery_bus_volt = 1;
inline void AircraftMiscSystem::clear_battery_bus_volt() {
  battery_bus_volt_ = 0;
}
inline double AircraftMiscSystem::_internal_battery_bus_volt() const {
  return battery_bus_volt_;
}
inline double AircraftMiscSystem::battery_bus_volt() const {
  // @@protoc_insertion_point(field_get:flight_panel.AircraftMiscSystem.battery_bus_volt)
  return _internal_battery_bus_volt();
}
inline void AircraftMiscSystem::_internal_set_battery_bus_volt(double value) {
  
  battery_bus_volt_ = value;
}
inline void AircraftMiscSystem::set_battery_bus_volt(double value) {
  _internal_set_battery_bus_volt(value);
  // @@protoc_insertion_point(field_set:flight_panel.AircraftMiscSystem.battery_bus_volt)
}

// double ambient_temp = 2;
inline void AircraftMiscSystem::clear_ambient_temp() {
  ambient_temp_ = 0;
}
inline double AircraftMiscSystem::_internal_ambient_temp() const {
  return ambient_temp_;
}
inline double AircraftMiscSystem::ambient_temp() const {
  // @@protoc_insertion_point(field_get:flight_panel.AircraftMiscSystem.ambient_temp)
  return _internal_ambient_temp();
}
inline void AircraftMiscSystem::_internal_set_ambient_temp(double value) {
  
  ambient_temp_ = value;
}
inline void AircraftMiscSystem::set_ambient_temp(double value) {
  _internal_set_ambient_temp(value);
  // @@protoc_insertion_point(field_set:flight_panel.AircraftMiscSystem.ambient_temp)
}

// -------------------------------------------------------------------

// EngineData

// double rpm = 1;
inline void EngineData::clear_rpm() {
  rpm_ = 0;
}
inline double EngineData::_internal_rpm() const {
  return rpm_;
}
inline double EngineData::rpm() const {
  // @@protoc_insertion_point(field_get:flight_panel.EngineData.rpm)
  return _internal_rpm();
}
inline void EngineData::_internal_set_rpm(double value) {
  
  rpm_ = value;
}
inline void EngineData::set_rpm(double value) {
  _internal_set_rpm(value);
  // @@protoc_insertion_point(field_set:flight_panel.EngineData.rpm)
}

// double rpm_ambiemt_pct = 2;
inline void EngineData::clear_rpm_ambiemt_pct() {
  rpm_ambiemt_pct_ = 0;
}
inline double EngineData::_internal_rpm_ambiemt_pct() const {
  return rpm_ambiemt_pct_;
}
inline double EngineData::rpm_ambiemt_pct() const {
  // @@protoc_insertion_point(field_get:flight_panel.EngineData.rpm_ambiemt_pct)
  return _internal_rpm_ambiemt_pct();
}
inline void EngineData::_internal_set_rpm_ambiemt_pct(double value) {
  
  rpm_ambiemt_pct_ = value;
}
inline void EngineData::set_rpm_ambiemt_pct(double value) {
  _internal_set_rpm_ambiemt_pct(value);
  // @@protoc_insertion_point(field_set:flight_panel.EngineData.rpm_ambiemt_pct)
}

// double engine_elapsed_time = 3;
inline void EngineData::clear_engine_elapsed_time() {
  engine_elapsed_time_ = 0;
}
inline double EngineData::_internal_engine_elapsed_time() const {
  return engine_elapsed_time_;
}
inline double EngineData::engine_elapsed_time() const {
  // @@protoc_insertion_point(field_get:flight_panel.EngineData.engine_elapsed_time)
  return _internal_engine_elapsed_time();
}
inline void EngineData::_internal_set_engine_elapsed_time(double value) {
  
  engine_elapsed_time_ = value;
}
inline void EngineData::set_engine_elapsed_time(double value) {
  _internal_set_engine_elapsed_time(value);
  // @@protoc_insertion_point(field_set:flight_panel.EngineData.engine_elapsed_time)
}

// double fuel_left_level = 4;
inline void EngineData::clear_fuel_left_level() {
  fuel_left_level_ = 0;
}
inline double EngineData::_internal_fuel_left_level() const {
  return fuel_left_level_;
}
inline double EngineData::fuel_left_level() const {
  // @@protoc_insertion_point(field_get:flight_panel.EngineData.fuel_left_level)
  return _internal_fuel_left_level();
}
inline void EngineData::_internal_set_fuel_left_level(double value) {
  
  fuel_left_level_ = value;
}
inline void EngineData::set_fuel_left_level(double value) {
  _internal_set_fuel_left_level(value);
  // @@protoc_insertion_point(field_set:flight_panel.EngineData.fuel_left_level)
}

// double fuel_right_level = 5;
inline void EngineData::clear_fuel_right_level() {
  fuel_right_level_ = 0;
}
inline double EngineData::_internal_fuel_right_level() const {
  return fuel_right_level_;
}
inline double EngineData::fuel_right_level() const {
  // @@protoc_insertion_point(field_get:flight_panel.EngineData.fuel_right_level)
  return _internal_fuel_right_level();
}
inline void EngineData::_internal_set_fuel_right_level(double value) {
  
  fuel_right_level_ = value;
}
inline void EngineData::set_fuel_right_level(double value) {
  _internal_set_fuel_right_level(value);
  // @@protoc_insertion_point(field_set:flight_panel.EngineData.fuel_right_level)
}

// -------------------------------------------------------------------

// Instrument

// double indicated_altitude = 1;
inline void Instrument::clear_indicated_altitude() {
  indicated_altitude_ = 0;
}
inline double Instrument::_internal_indicated_altitude() const {
  return indicated_altitude_;
}
inline double Instrument::indicated_altitude() const {
  // @@protoc_insertion_point(field_get:flight_panel.Instrument.indicated_altitude)
  return _internal_indicated_altitude();
}
inline void Instrument::_internal_set_indicated_altitude(double value) {
  
  indicated_altitude_ = value;
}
inline void Instrument::set_indicated_altitude(double value) {
  _internal_set_indicated_altitude(value);
  // @@protoc_insertion_point(field_set:flight_panel.Instrument.indicated_altitude)
}

// double kohlsman_setting_hg = 2;
inline void Instrument::clear_kohlsman_setting_hg() {
  kohlsman_setting_hg_ = 0;
}
inline double Instrument::_internal_kohlsman_setting_hg() const {
  return kohlsman_setting_hg_;
}
inline double Instrument::kohlsman_setting_hg() const {
  // @@protoc_insertion_point(field_get:flight_panel.Instrument.kohlsman_setting_hg)
  return _internal_kohlsman_setting_hg();
}
inline void Instrument::_internal_set_kohlsman_setting_hg(double value) {
  
  kohlsman_setting_hg_ = value;
}
inline void Instrument::set_kohlsman_setting_hg(double value) {
  _internal_set_kohlsman_setting_hg(value);
  // @@protoc_insertion_point(field_set:flight_panel.Instrument.kohlsman_setting_hg)
}

// double vertical_speed = 3;
inline void Instrument::clear_vertical_speed() {
  vertical_speed_ = 0;
}
inline double Instrument::_internal_vertical_speed() const {
  return vertical_speed_;
}
inline double Instrument::vertical_speed() const {
  // @@protoc_insertion_point(field_get:flight_panel.Instrument.vertical_speed)
  return _internal_vertical_speed();
}
inline void Instrument::_internal_set_vertical_speed(double value) {
  
  vertical_speed_ = value;
}
inline void Instrument::set_vertical_speed(double value) {
  _internal_set_vertical_speed(value);
  // @@protoc_insertion_point(field_set:flight_panel.Instrument.vertical_speed)
}

// double pitch_angle = 4;
inline void Instrument::clear_pitch_angle() {
  pitch_angle_ = 0;
}
inline double Instrument::_internal_pitch_angle() const {
  return pitch_angle_;
}
inline double Instrument::pitch_angle() const {
  // @@protoc_insertion_point(field_get:flight_panel.Instrument.pitch_angle)
  return _internal_pitch_angle();
}
inline void Instrument::_internal_set_pitch_angle(double value) {
  
  pitch_angle_ = value;
}
inline void Instrument::set_pitch_angle(double value) {
  _internal_set_pitch_angle(value);
  // @@protoc_insertion_point(field_set:flight_panel.Instrument.pitch_angle)
}

// double bank_angle = 5;
inline void Instrument::clear_bank_angle() {
  bank_angle_ = 0;
}
inline double Instrument::_internal_bank_angle() const {
  return bank_angle_;
}
inline double Instrument::bank_angle() const {
  // @@protoc_insertion_point(field_get:flight_panel.Instrument.bank_angle)
  return _internal_bank_angle();
}
inline void Instrument::_internal_set_bank_angle(double value) {
  
  bank_angle_ = value;
}
inline void Instrument::set_bank_angle(double value) {
  _internal_set_bank_angle(value);
  // @@protoc_insertion_point(field_set:flight_panel.Instrument.bank_angle)
}

// double indicated_airspeed = 6;
inline void Instrument::clear_indicated_airspeed() {
  indicated_airspeed_ = 0;
}
inline double Instrument::_internal_indicated_airspeed() const {
  return indicated_airspeed_;
}
inline double Instrument::indicated_airspeed() const {
  // @@protoc_insertion_point(field_get:flight_panel.Instrument.indicated_airspeed)
  return _internal_indicated_airspeed();
}
inline void Instrument::_internal_set_indicated_airspeed(double value) {
  
  indicated_airspeed_ = value;
}
inline void Instrument::set_indicated_airspeed(double value) {
  _internal_set_indicated_airspeed(value);
  // @@protoc_insertion_point(field_set:flight_panel.Instrument.indicated_airspeed)
}

// double true_airspeed = 7;
inline void Instrument::clear_true_airspeed() {
  true_airspeed_ = 0;
}
inline double Instrument::_internal_true_airspeed() const {
  return true_airspeed_;
}
inline double Instrument::true_airspeed() const {
  // @@protoc_insertion_point(field_get:flight_panel.Instrument.true_airspeed)
  return _internal_true_airspeed();
}
inline void Instrument::_internal_set_true_airspeed(double value) {
  
  true_airspeed_ = value;
}
inline void Instrument::set_true_airspeed(double value) {
  _internal_set_true_airspeed(value);
  // @@protoc_insertion_point(field_set:flight_panel.Instrument.true_airspeed)
}

// double mach_speed = 8;
inline void Instrument::clear_mach_speed() {
  mach_speed_ = 0;
}
inline double Instrument::_internal_mach_speed() const {
  return mach_speed_;
}
inline double Instrument::mach_speed() const {
  // @@protoc_insertion_point(field_get:flight_panel.Instrument.mach_speed)
  return _internal_mach_speed();
}
inline void Instrument::_internal_set_mach_speed(double value) {
  
  mach_speed_ = value;
}
inline void Instrument::set_mach_speed(double value) {
  _internal_set_mach_speed(value);
  // @@protoc_insertion_point(field_set:flight_panel.Instrument.mach_speed)
}

// double turn_indicator_rate = 9;
inline void Instrument::clear_turn_indicator_rate() {
  turn_indicator_rate_ = 0;
}
inline double Instrument::_internal_turn_indicator_rate() const {
  return turn_indicator_rate_;
}
inline double Instrument::turn_indicator_rate() const {
  // @@protoc_insertion_point(field_get:flight_panel.Instrument.turn_indicator_rate)
  return _internal_turn_indicator_rate();
}
inline void Instrument::_internal_set_turn_indicator_rate(double value) {
  
  turn_indicator_rate_ = value;
}
inline void Instrument::set_turn_indicator_rate(double value) {
  _internal_set_turn_indicator_rate(value);
  // @@protoc_insertion_point(field_set:flight_panel.Instrument.turn_indicator_rate)
}

// double turn_coordinator_ball = 10;
inline void Instrument::clear_turn_coordinator_ball() {
  turn_coordinator_ball_ = 0;
}
inline double Instrument::_internal_turn_coordinator_ball() const {
  return turn_coordinator_ball_;
}
inline double Instrument::turn_coordinator_ball() const {
  // @@protoc_insertion_point(field_get:flight_panel.Instrument.turn_coordinator_ball)
  return _internal_turn_coordinator_ball();
}
inline void Instrument::_internal_set_turn_coordinator_ball(double value) {
  
  turn_coordinator_ball_ = value;
}
inline void Instrument::set_turn_coordinator_ball(double value) {
  _internal_set_turn_coordinator_ball(value);
  // @@protoc_insertion_point(field_set:flight_panel.Instrument.turn_coordinator_ball)
}

// double heading_indicator_deg = 11;
inline void Instrument::clear_heading_indicator_deg() {
  heading_indicator_deg_ = 0;
}
inline double Instrument::_internal_heading_indicator_deg() const {
  return heading_indicator_deg_;
}
inline double Instrument::heading_indicator_deg() const {
  // @@protoc_insertion_point(field_get:flight_panel.Instrument.heading_indicator_deg)
  return _internal_heading_indicator_deg();
}
inline void Instrument::_internal_set_heading_indicator_deg(double value) {
  
  heading_indicator_deg_ = value;
}
inline void Instrument::set_heading_indicator_deg(double value) {
  _internal_set_heading_indicator_deg(value);
  // @@protoc_insertion_point(field_set:flight_panel.Instrument.heading_indicator_deg)
}

// -------------------------------------------------------------------

// AircraftControls

// double elevator_trim_indicator = 1;
inline void AircraftControls::clear_elevator_trim_indicator() {
  elevator_trim_indicator_ = 0;
}
inline double AircraftControls::_internal_elevator_trim_indicator() const {
  return elevator_trim_indicator_;
}
inline double AircraftControls::elevator_trim_indicator() const {
  // @@protoc_insertion_point(field_get:flight_panel.AircraftControls.elevator_trim_indicator)
  return _internal_elevator_trim_indicator();
}
inline void AircraftControls::_internal_set_elevator_trim_indicator(double value) {
  
  elevator_trim_indicator_ = value;
}
inline void AircraftControls::set_elevator_trim_indicator(double value) {
  _internal_set_elevator_trim_indicator(value);
  // @@protoc_insertion_point(field_set:flight_panel.AircraftControls.elevator_trim_indicator)
}

// int32 flaps_count = 2;
inline void AircraftControls::clear_flaps_count() {
  flaps_count_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AircraftControls::_internal_flaps_count() const {
  return flaps_count_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AircraftControls::flaps_count() const {
  // @@protoc_insertion_point(field_get:flight_panel.AircraftControls.flaps_count)
  return _internal_flaps_count();
}
inline void AircraftControls::_internal_set_flaps_count(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  flaps_count_ = value;
}
inline void AircraftControls::set_flaps_count(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_flaps_count(value);
  // @@protoc_insertion_point(field_set:flight_panel.AircraftControls.flaps_count)
}

// int32 flaps_pos = 3;
inline void AircraftControls::clear_flaps_pos() {
  flaps_pos_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AircraftControls::_internal_flaps_pos() const {
  return flaps_pos_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AircraftControls::flaps_pos() const {
  // @@protoc_insertion_point(field_get:flight_panel.AircraftControls.flaps_pos)
  return _internal_flaps_pos();
}
inline void AircraftControls::_internal_set_flaps_pos(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  flaps_pos_ = value;
}
inline void AircraftControls::set_flaps_pos(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_flaps_pos(value);
  // @@protoc_insertion_point(field_set:flight_panel.AircraftControls.flaps_pos)
}

// -------------------------------------------------------------------

// GameData

// bool connected = 1;
inline void GameData::clear_connected() {
  connected_ = false;
}
inline bool GameData::_internal_connected() const {
  return connected_;
}
inline bool GameData::connected() const {
  // @@protoc_insertion_point(field_get:flight_panel.GameData.connected)
  return _internal_connected();
}
inline void GameData::_internal_set_connected(bool value) {
  
  connected_ = value;
}
inline void GameData::set_connected(bool value) {
  _internal_set_connected(value);
  // @@protoc_insertion_point(field_set:flight_panel.GameData.connected)
}

// -------------------------------------------------------------------

// NavigationSystem

// .flight_panel.NavigationSystem.NavSource active_nav_source = 1;
inline void NavigationSystem::clear_active_nav_source() {
  active_nav_source_ = 0;
}
inline ::flight_panel::NavigationSystem_NavSource NavigationSystem::_internal_active_nav_source() const {
  return static_cast< ::flight_panel::NavigationSystem_NavSource >(active_nav_source_);
}
inline ::flight_panel::NavigationSystem_NavSource NavigationSystem::active_nav_source() const {
  // @@protoc_insertion_point(field_get:flight_panel.NavigationSystem.active_nav_source)
  return _internal_active_nav_source();
}
inline void NavigationSystem::_internal_set_active_nav_source(::flight_panel::NavigationSystem_NavSource value) {
  
  active_nav_source_ = value;
}
inline void NavigationSystem::set_active_nav_source(::flight_panel::NavigationSystem_NavSource value) {
  _internal_set_active_nav_source(value);
  // @@protoc_insertion_point(field_set:flight_panel.NavigationSystem.active_nav_source)
}

// .flight_panel.HorizontalSituationIndicator hsi_1 = 2;
inline bool NavigationSystem::_internal_has_hsi_1() const {
  return this != internal_default_instance() && hsi_1_ != nullptr;
}
inline bool NavigationSystem::has_hsi_1() const {
  return _internal_has_hsi_1();
}
inline void NavigationSystem::clear_hsi_1() {
  if (GetArena() == nullptr && hsi_1_ != nullptr) {
    delete hsi_1_;
  }
  hsi_1_ = nullptr;
}
inline const ::flight_panel::HorizontalSituationIndicator& NavigationSystem::_internal_hsi_1() const {
  const ::flight_panel::HorizontalSituationIndicator* p = hsi_1_;
  return p != nullptr ? *p : *reinterpret_cast<const ::flight_panel::HorizontalSituationIndicator*>(
      &::flight_panel::_HorizontalSituationIndicator_default_instance_);
}
inline const ::flight_panel::HorizontalSituationIndicator& NavigationSystem::hsi_1() const {
  // @@protoc_insertion_point(field_get:flight_panel.NavigationSystem.hsi_1)
  return _internal_hsi_1();
}
inline void NavigationSystem::unsafe_arena_set_allocated_hsi_1(
    ::flight_panel::HorizontalSituationIndicator* hsi_1) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(hsi_1_);
  }
  hsi_1_ = hsi_1;
  if (hsi_1) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flight_panel.NavigationSystem.hsi_1)
}
inline ::flight_panel::HorizontalSituationIndicator* NavigationSystem::release_hsi_1() {
  
  ::flight_panel::HorizontalSituationIndicator* temp = hsi_1_;
  hsi_1_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::flight_panel::HorizontalSituationIndicator* NavigationSystem::unsafe_arena_release_hsi_1() {
  // @@protoc_insertion_point(field_release:flight_panel.NavigationSystem.hsi_1)
  
  ::flight_panel::HorizontalSituationIndicator* temp = hsi_1_;
  hsi_1_ = nullptr;
  return temp;
}
inline ::flight_panel::HorizontalSituationIndicator* NavigationSystem::_internal_mutable_hsi_1() {
  
  if (hsi_1_ == nullptr) {
    auto* p = CreateMaybeMessage<::flight_panel::HorizontalSituationIndicator>(GetArena());
    hsi_1_ = p;
  }
  return hsi_1_;
}
inline ::flight_panel::HorizontalSituationIndicator* NavigationSystem::mutable_hsi_1() {
  // @@protoc_insertion_point(field_mutable:flight_panel.NavigationSystem.hsi_1)
  return _internal_mutable_hsi_1();
}
inline void NavigationSystem::set_allocated_hsi_1(::flight_panel::HorizontalSituationIndicator* hsi_1) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete hsi_1_;
  }
  if (hsi_1) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(hsi_1);
    if (message_arena != submessage_arena) {
      hsi_1 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, hsi_1, submessage_arena);
    }
    
  } else {
    
  }
  hsi_1_ = hsi_1;
  // @@protoc_insertion_point(field_set_allocated:flight_panel.NavigationSystem.hsi_1)
}

// .flight_panel.HorizontalSituationIndicator hsi_2 = 3;
inline bool NavigationSystem::_internal_has_hsi_2() const {
  return this != internal_default_instance() && hsi_2_ != nullptr;
}
inline bool NavigationSystem::has_hsi_2() const {
  return _internal_has_hsi_2();
}
inline void NavigationSystem::clear_hsi_2() {
  if (GetArena() == nullptr && hsi_2_ != nullptr) {
    delete hsi_2_;
  }
  hsi_2_ = nullptr;
}
inline const ::flight_panel::HorizontalSituationIndicator& NavigationSystem::_internal_hsi_2() const {
  const ::flight_panel::HorizontalSituationIndicator* p = hsi_2_;
  return p != nullptr ? *p : *reinterpret_cast<const ::flight_panel::HorizontalSituationIndicator*>(
      &::flight_panel::_HorizontalSituationIndicator_default_instance_);
}
inline const ::flight_panel::HorizontalSituationIndicator& NavigationSystem::hsi_2() const {
  // @@protoc_insertion_point(field_get:flight_panel.NavigationSystem.hsi_2)
  return _internal_hsi_2();
}
inline void NavigationSystem::unsafe_arena_set_allocated_hsi_2(
    ::flight_panel::HorizontalSituationIndicator* hsi_2) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(hsi_2_);
  }
  hsi_2_ = hsi_2;
  if (hsi_2) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flight_panel.NavigationSystem.hsi_2)
}
inline ::flight_panel::HorizontalSituationIndicator* NavigationSystem::release_hsi_2() {
  
  ::flight_panel::HorizontalSituationIndicator* temp = hsi_2_;
  hsi_2_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::flight_panel::HorizontalSituationIndicator* NavigationSystem::unsafe_arena_release_hsi_2() {
  // @@protoc_insertion_point(field_release:flight_panel.NavigationSystem.hsi_2)
  
  ::flight_panel::HorizontalSituationIndicator* temp = hsi_2_;
  hsi_2_ = nullptr;
  return temp;
}
inline ::flight_panel::HorizontalSituationIndicator* NavigationSystem::_internal_mutable_hsi_2() {
  
  if (hsi_2_ == nullptr) {
    auto* p = CreateMaybeMessage<::flight_panel::HorizontalSituationIndicator>(GetArena());
    hsi_2_ = p;
  }
  return hsi_2_;
}
inline ::flight_panel::HorizontalSituationIndicator* NavigationSystem::mutable_hsi_2() {
  // @@protoc_insertion_point(field_mutable:flight_panel.NavigationSystem.hsi_2)
  return _internal_mutable_hsi_2();
}
inline void NavigationSystem::set_allocated_hsi_2(::flight_panel::HorizontalSituationIndicator* hsi_2) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete hsi_2_;
  }
  if (hsi_2) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(hsi_2);
    if (message_arena != submessage_arena) {
      hsi_2 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, hsi_2, submessage_arena);
    }
    
  } else {
    
  }
  hsi_2_ = hsi_2;
  // @@protoc_insertion_point(field_set_allocated:flight_panel.NavigationSystem.hsi_2)
}

// double next_waypoint_distance = 19;
inline void NavigationSystem::clear_next_waypoint_distance() {
  next_waypoint_distance_ = 0;
}
inline double NavigationSystem::_internal_next_waypoint_distance() const {
  return next_waypoint_distance_;
}
inline double NavigationSystem::next_waypoint_distance() const {
  // @@protoc_insertion_point(field_get:flight_panel.NavigationSystem.next_waypoint_distance)
  return _internal_next_waypoint_distance();
}
inline void NavigationSystem::_internal_set_next_waypoint_distance(double value) {
  
  next_waypoint_distance_ = value;
}
inline void NavigationSystem::set_next_waypoint_distance(double value) {
  _internal_set_next_waypoint_distance(value);
  // @@protoc_insertion_point(field_set:flight_panel.NavigationSystem.next_waypoint_distance)
}

// string next_waypoint_name = 20;
inline void NavigationSystem::clear_next_waypoint_name() {
  next_waypoint_name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& NavigationSystem::next_waypoint_name() const {
  // @@protoc_insertion_point(field_get:flight_panel.NavigationSystem.next_waypoint_name)
  return _internal_next_waypoint_name();
}
inline void NavigationSystem::set_next_waypoint_name(const std::string& value) {
  _internal_set_next_waypoint_name(value);
  // @@protoc_insertion_point(field_set:flight_panel.NavigationSystem.next_waypoint_name)
}
inline std::string* NavigationSystem::mutable_next_waypoint_name() {
  // @@protoc_insertion_point(field_mutable:flight_panel.NavigationSystem.next_waypoint_name)
  return _internal_mutable_next_waypoint_name();
}
inline const std::string& NavigationSystem::_internal_next_waypoint_name() const {
  return next_waypoint_name_.Get();
}
inline void NavigationSystem::_internal_set_next_waypoint_name(const std::string& value) {
  
  next_waypoint_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void NavigationSystem::set_next_waypoint_name(std::string&& value) {
  
  next_waypoint_name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:flight_panel.NavigationSystem.next_waypoint_name)
}
inline void NavigationSystem::set_next_waypoint_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  next_waypoint_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:flight_panel.NavigationSystem.next_waypoint_name)
}
inline void NavigationSystem::set_next_waypoint_name(const char* value,
    size_t size) {
  
  next_waypoint_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:flight_panel.NavigationSystem.next_waypoint_name)
}
inline std::string* NavigationSystem::_internal_mutable_next_waypoint_name() {
  
  return next_waypoint_name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* NavigationSystem::release_next_waypoint_name() {
  // @@protoc_insertion_point(field_release:flight_panel.NavigationSystem.next_waypoint_name)
  return next_waypoint_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void NavigationSystem::set_allocated_next_waypoint_name(std::string* next_waypoint_name) {
  if (next_waypoint_name != nullptr) {
    
  } else {
    
  }
  next_waypoint_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), next_waypoint_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:flight_panel.NavigationSystem.next_waypoint_name)
}

// string last_waypoint_name = 21;
inline void NavigationSystem::clear_last_waypoint_name() {
  last_waypoint_name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& NavigationSystem::last_waypoint_name() const {
  // @@protoc_insertion_point(field_get:flight_panel.NavigationSystem.last_waypoint_name)
  return _internal_last_waypoint_name();
}
inline void NavigationSystem::set_last_waypoint_name(const std::string& value) {
  _internal_set_last_waypoint_name(value);
  // @@protoc_insertion_point(field_set:flight_panel.NavigationSystem.last_waypoint_name)
}
inline std::string* NavigationSystem::mutable_last_waypoint_name() {
  // @@protoc_insertion_point(field_mutable:flight_panel.NavigationSystem.last_waypoint_name)
  return _internal_mutable_last_waypoint_name();
}
inline const std::string& NavigationSystem::_internal_last_waypoint_name() const {
  return last_waypoint_name_.Get();
}
inline void NavigationSystem::_internal_set_last_waypoint_name(const std::string& value) {
  
  last_waypoint_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void NavigationSystem::set_last_waypoint_name(std::string&& value) {
  
  last_waypoint_name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:flight_panel.NavigationSystem.last_waypoint_name)
}
inline void NavigationSystem::set_last_waypoint_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  last_waypoint_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:flight_panel.NavigationSystem.last_waypoint_name)
}
inline void NavigationSystem::set_last_waypoint_name(const char* value,
    size_t size) {
  
  last_waypoint_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:flight_panel.NavigationSystem.last_waypoint_name)
}
inline std::string* NavigationSystem::_internal_mutable_last_waypoint_name() {
  
  return last_waypoint_name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* NavigationSystem::release_last_waypoint_name() {
  // @@protoc_insertion_point(field_release:flight_panel.NavigationSystem.last_waypoint_name)
  return last_waypoint_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void NavigationSystem::set_allocated_last_waypoint_name(std::string* last_waypoint_name) {
  if (last_waypoint_name != nullptr) {
    
  } else {
    
  }
  last_waypoint_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), last_waypoint_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:flight_panel.NavigationSystem.last_waypoint_name)
}

// -------------------------------------------------------------------

// HorizontalSituationIndicator

// double course = 1;
inline void HorizontalSituationIndicator::clear_course() {
  course_ = 0;
}
inline double HorizontalSituationIndicator::_internal_course() const {
  return course_;
}
inline double HorizontalSituationIndicator::course() const {
  // @@protoc_insertion_point(field_get:flight_panel.HorizontalSituationIndicator.course)
  return _internal_course();
}
inline void HorizontalSituationIndicator::_internal_set_course(double value) {
  
  course_ = value;
}
inline void HorizontalSituationIndicator::set_course(double value) {
  _internal_set_course(value);
  // @@protoc_insertion_point(field_set:flight_panel.HorizontalSituationIndicator.course)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace flight_panel

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::flight_panel::CourseDeviationIndicator_Direction> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::flight_panel::CourseDeviationIndicator_Direction>() {
  return ::flight_panel::CourseDeviationIndicator_Direction_descriptor();
}
template <> struct is_proto_enum< ::flight_panel::NavigationSystem_NavSource> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::flight_panel::NavigationSystem_NavSource>() {
  return ::flight_panel::NavigationSystem_NavSource_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_sim_5fdata_2eproto
